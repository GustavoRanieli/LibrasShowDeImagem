!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],n):n((e=e||self).tf=e.tf||{},e.tf)}(this,function(e,D){"use strict";var E=function(e,n){return(E=Object.setPrototypeOf||({__proto__:[]}instanceof Array?function(e,n){e.__proto__=n}:function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])}))(e,n)};function S(e,o,s,u){return new(s=s||Promise)(function(t,n){function r(e){try{i(u.next(e))}catch(e){n(e)}}function a(e){try{i(u.throw(e))}catch(e){n(e)}}function i(e){var n;e.done?t(e.value):((n=e.value)instanceof s?n:new s(function(e){e(n)})).then(r,a)}i((u=u.apply(e,o||[])).next())})}function A(r,a){var i,o,s,u={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]},e={next:n(0),throw:n(1),return:n(2)};return"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function n(t){return function(e){var n=[t,e];if(i)throw new TypeError("Generator is already executing.");for(;u;)try{if(i=1,o&&(s=2&n[0]?o.return:n[0]?o.throw||((s=o.return)&&s.call(o),0):o.next)&&!(s=s.call(o,n[1])).done)return s;switch(o=0,(n=s?[2&n[0],s.value]:n)[0]){case 0:case 1:s=n;break;case 4:return u.label++,{value:n[1],done:!1};case 5:u.label++,o=n[1],n=[0];continue;case 7:n=u.ops.pop(),u.trys.pop();continue;default:if(!(s=0<(s=u.trys).length&&s[s.length-1])&&(6===n[0]||2===n[0])){u=0;continue}if(3===n[0]&&(!s||n[1]>s[0]&&n[1]<s[3]))u.label=n[1];else if(6===n[0]&&u.label<s[1])u.label=s[1],s=n;else{if(!(s&&u.label<s[2])){s[2]&&u.ops.pop(),u.trys.pop();continue}u.label=s[2],u.ops.push(n)}}n=a.call(r,u)}catch(e){n=[6,e],o=0}finally{i=s=0}if(5&n[0])throw n[1];return{value:n[0]?n[1]:void 0,done:!0}}}}var F,f,o,t={},_={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function G(e,n){t[e]=n}function i(e){if(!(e in t)){var n=function(n){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=function(e){{if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}}(n);return e.addEventListener("webglcontextlost",function(e){e.preventDefault(),delete t[n]},!1),1!==n?e.getContext("webgl2",_):e.getContext("webgl",_)||e.getContext("experimental-webgl",_)}(e);if(null===n)return console.log("Could not get context for WebGL version",e),null;t[e]=n}n=t[e];return n.isContextLost()?(delete t[e],i(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),t[e])}function U(e,n){return[n,e]}function z(e){e=D.util.sizeFromShape(e),e=Math.ceil(e/4);return D.util.sizeToSquarishShape(e)}function x(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function X(e,n){var t,r,a,i,o,s,u,l,d=e,d=(2===D.env().getNumber("WEBGL_VERSION")?(t=d.R32F,r=d.R16F,a=d.RGBA16F,i=d.RGBA32F,o=d.RED,s=4,u=1,l=d.HALF_FLOAT,d):(t=e.RGBA,r=e.RGBA,a=e.RGBA,i=d.RGBA,o=e.RGBA,u=s=4,l=null!=n?n.HALF_FLOAT_OES:null,e)).FLOAT;return{internalFormatFloat:t,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:e.RGBA,downloadUnpackNumChannels:s,defaultNumChannels:u,textureTypeHalfFloat:l,textureTypeFloat:d}}function c(e,n){n=n();if(D.env().getBool("DEBUG")){var t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+j(e,t))}return n}(n=F=F||{})[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",(n=f=f||{})[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",(n=o=o||{})[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";function H(e){return!!(D.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function j(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+n}}function K(e,n){return p(e,function(){return e.getExtension(n)},'Extension "'+n+'" not supported on this browser.')}function q(e,n){var t=p(e,function(){return e.createShader(e.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(c(e,function(){return e.shaderSource(t,n)}),c(e,function(){return e.compileShader(t)}),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Y(e,n){var t=p(e,function(){return e.createShader(e.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(c(e,function(){return e.shaderSource(t,n)}),c(e,function(){return e.compileShader(t)}),!1!==e.getShaderParameter(t,e.COMPILE_STATUS))return t;var r=n,a=e.getShaderInfoLog(t);if(null==(i=$.exec(a)))console.log("Couldn't parse line number in error: "+a),console.log(r);else{for(var i=+i[1],r=r.split("\n"),o=r.length.toString().length+2,s=r.map(function(e,n){return D.util.rightPad((n+1).toString(),o)+e}),u=0,l=0;l<s.length;l++)u=Math.max(s[l].length,u);var r=s.slice(0,i-1),d=s.slice(i-1,i),i=s.slice(i);console.log(r.join("\n")),console.log(a.split("\n")[0]),console.log("%c "+D.util.rightPad(d[0],u),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(i.join("\n"))}throw new Error("Failed to compile fragment shader.")}var Q,Z,$=/ERROR: [0-9]+:([0-9]+):/g;function J(e){return p(e,function(){return e.createProgram()},"Unable to create WebGLProgram.")}function ee(e,n){if(c(e,function(){return e.linkProgram(n)}),!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function ne(e,n){if(c(e,function(){return e.validateProgram(n)}),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function te(e,n){var t=p(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return c(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,t)}),c(e,function(){return e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)}),t}function re(e,n){var t=p(e,function(){return e.createBuffer()},"Unable to create WebGLBuffer");return c(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)}),c(e,function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)}),t}function ae(e){return p(e,function(){return e.createTexture()},"Unable to create WebGLTexture.")}function ie(e,n){var t,r=D.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0)throw t="["+e+"x"+n+"]",new Error("Requested texture size "+t+" is invalid.");if(r<e||r<n)throw t="["+e+"x"+n+"]",new Error("Requested texture size "+t+" greater than WebGL maximum on this browser / GPU "+("["+r+"x"+r+"]")+".")}function oe(e){return p(e,function(){return e.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function se(e,n,t,r,a,i,o){var s=e.getAttribLocation(n,t);return-1!==s&&(c(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,r)}),c(e,function(){return e.vertexAttribPointer(s,a,e.FLOAT,!1,i,o)}),c(e,function(){return e.enableVertexAttribArray(s)}),!0)}function ue(e,n,t){ge(e,t),c(e,function(){return e.activeTexture(e.TEXTURE0+t)}),c(e,function(){return e.bindTexture(e.TEXTURE_2D,n)})}function le(e,n,t){return p(e,function(){return e.getUniformLocation(n,t)},'uniform "'+t+'" not present in program.')}function de(e,n,t){return e.getUniformLocation(n,t)}function ce(e,n,t,r){c(e,function(){return ue(e,n,r)}),c(e,function(){return e.uniform1i(t,r)})}function pe(e,n,t){c(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)}),c(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)})}function he(e,n){c(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,n)}),c(e,function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)})}function fe(e){var n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+xe(e,n))}function xe(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+n}}function p(e,n,t){e=c(e,function(){return n()});if(null==e)throw new Error(t);return e}function ge(e,n){var t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=n+e.TEXTURE0;if(n<e.TEXTURE0||t<n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+t+"]")+".")}function d(e,n){return D.util.sizeFromShape(e.slice(0,e.length-(n=void 0===n?2:n)))}function h(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[1<e.length?e[e.length-2]:1,e[e.length-1]]}function me(e){var n=[1,1,1];return n=0===e.length||1===e.length&&1===e[0]?n:[d(e)].concat(h(e))}function ve(t,e){void 0===e&&(e=!1);var n,r,a=D.env().getNumber("WEBGL_MAX_TEXTURE_SIZE"),i=(2!==(t=e&&(a*=2,1===(t=t.map(function(e,n){return n>=t.length-2?D.util.nearestLargerEven(t[n]):t[n]})).length)?[2,t[0]]:t).length&&(i=D.util.squeezeShape(t),t=i.newShape),D.util.sizeFromShape(t));return t.length<=1&&i<=a?[1,i]:2===t.length&&t[0]<=a&&t[1]<=a?t:3===t.length&&t[0]*t[1]<=a&&t[2]<=a?[t[0]*t[1],t[2]]:3===t.length&&t[0]<=a&&t[1]*t[2]<=a?[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=a&&t[3]<=a?[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=a&&t[1]*t[2]*t[3]<=a?[t[0],t[1]*t[2]*t[3]]:e?(a=d(t),r=e=2,t.length&&(e=(n=h(t))[0],r=n[1]),D.util.sizeToSquarishShape(i=a*(e/2)*(r/2)).map(function(e){return 2*e})):D.util.sizeToSquarishShape(i)}function be(e){return e%2==0}function Ce(e,n){if(e=e.slice(-2),n=n.slice(-2),D.util.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){var t=e.slice(-1)[0],r=n.slice(-1)[0];if(t===r)return!0;if(be(t)&&be(r)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&be(e[0])&&be(n[0])}function ye(e){return null==Q&&(e=i(e),Q=e.getParameter(e.MAX_TEXTURE_SIZE)),Q}function ke(e){return null==Z&&(e=i(e),Z=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),Math.min(16,Z)}function Ie(e){var n;return 0===e?0:s(n=i(e),"EXT_disjoint_timer_query_webgl2")&&2===e?2:s(n,"EXT_disjoint_timer_query")?1:0}function s(e,n){return null!=e.getExtension(n)}function we(e){try{if(null!=i(e))return!0}catch(e){console.log("Error when getting WebGL context: ",e)}return!1}function Re(e){if(0===e)return!1;var n=i(e);if(1===e){if(!s(n,"OES_texture_float"))return!1}else if(!s(n,"EXT_color_buffer_float"))return!1;return Ne(n)}function Te(e){var n,t,r,a;return 0!==e&&(n=i(e),1!==e?s(n,"EXT_color_buffer_float")?Ne(n):!!s(n,e="EXT_color_buffer_half_float")&&(e=n.getExtension(e),e=X(t=n,e=e),r=t.createTexture(),t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null),e=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,e),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0),a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE,t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(e),a):!!s(n,"OES_texture_float")&&!!s(n,"WEBGL_color_buffer_float")&&Ne(n))}function Ne(e){var n=X(e),t=e.createTexture(),n=(e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null),e.createFramebuffer()),r=(e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE);return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(n),r}function Ee(e){return 2===e&&null!=i(e).fenceSync}function u(e,n){(e=Array.isArray(e)?e:[e]).forEach(function(e){null!=e&&D.util.assert("complex64"!==e.dtype,function(){return n+" does not support complex64 tensors in the WebGL backend."})})}var n={__proto__:null,callAndCheck:c,canBeRepresented:H,getWebGLErrorMessage:j,getExtensionOrThrow:K,createVertexShader:q,createFragmentShader:Y,createProgram:J,linkProgram:ee,validateProgram:ne,createStaticVertexBuffer:te,createStaticIndexBuffer:re,getNumChannels:function(){return 2===D.env().getNumber("WEBGL_VERSION")?1:4},createTexture:ae,validateTextureSize:ie,createFramebuffer:oe,bindVertexBufferToProgramAttribute:se,bindTextureUnit:ue,unbindTextureUnit:function(e,n){ge(e,n),c(e,function(){return e.activeTexture(e.TEXTURE0+n)}),c(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:le,getProgramUniformLocation:de,bindTextureToProgramUniformSampler:ce,bindCanvasToFramebuffer:function(e){c(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),c(e,function(){return e.viewport(0,0,e.canvas.width,e.canvas.height)}),c(e,function(){return e.scissor(0,0,e.canvas.width,e.canvas.height)})},bindColorTextureToFramebuffer:pe,unbindColorTextureFromFramebuffer:he,validateFramebuffer:fe,getFramebufferErrorMessage:xe,getBatchDim:d,getRowsCols:h,getShapeAs3D:me,getTextureShapeFromLogicalShape:ve,isReshapeFree:Ce,getWebGLMaxTextureSize:ye,resetMaxTextureSize:function(){Q=null},resetMaxTexturesInShader:function(){Z=null},getMaxTexturesInShader:ke,getWebGLDisjointQueryTimerVersion:Ie,hasExtension:s,isWebGLVersionEnabled:we,isCapableOfRenderingToFloatTexture:Re,isDownloadFloatTextureEnabled:Te,isWebGLFenceEnabled:Ee,assertNotComplex:u},r=D.env();function k(){var e,n,t,r,a,i,o,s,u,l=2===D.env().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="out",r=n="in",a="texture",i="outputColor",o="out vec4 outputColor;",s="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="","\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="attribute",r=t="varying",a="texture2D",i="gl_FragColor",o=e="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ","\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ");return{version:e,attribute:n,varyingVs:t,varyingFs:r,texture2D:a,output:i,defineOutput:o,defineSpecialNaN:s,defineSpecialInf:u,defineRound:l}}function g(t,e,r){void 0===r&&(r="index");var a=D.util.computeStrides(e);return a.map(function(e,n){return"int "+t[n]+" = "+r+" / "+e+"; "+(n===a.length-1?"int "+t[n+1]+" = "+r+" - "+t[n]+" * "+e:"index -= "+t[n]+" * "+e)+";"}).join("")}function Se(e){e=D.util.computeStrides(e).map(function(e){return e.toString()});return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * "+e[0]+" + coords.y * "+e[1]+" + coords.z;\n  }\n"}r.registerFlag("HAS_WEBGL",function(){return 0<r.getNumber("WEBGL_VERSION")}),r.registerFlag("WEBGL_VERSION",function(){return we(2)?2:we(1)?1:0}),r.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",function(){return!1}),r.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===r.get("WEBGL_VERSION")}),r.registerFlag("WEBGL_CPU_FORWARD",function(){return!0}),r.registerFlag("WEBGL_FORCE_F16_TEXTURES",function(){return!1}),r.registerFlag("WEBGL_PACK",function(){return r.getBool("HAS_WEBGL")}),r.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_CLIP",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_PACK_REDUCE",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_LAZILY_UNPACK",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_CONV_IM2COL",function(){return r.getBool("WEBGL_PACK")}),r.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return ye(r.getNumber("WEBGL_VERSION"))}),r.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return ke(r.getNumber("WEBGL_VERSION"))}),r.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var e=r.getNumber("WEBGL_VERSION");return 0===e?0:Ie(e)}),r.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return 0<r.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")&&!D.device_util.isMobile()}),r.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",function(){return Re(r.getNumber("WEBGL_VERSION"))}),r.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return!r.getBool("WEBGL_FORCE_F16_TEXTURES")&&r.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")}),r.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Te(r.getNumber("WEBGL_VERSION"))}),r.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return Ee(r.getNumber("WEBGL_VERSION"))}),r.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return r.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),r.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",function(){return-1},function(e){if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+e+".")}),r.registerFlag("WEBGL_FLUSH_THRESHOLD",function(){return D.device_util.isMobile()&&r.getBool("IS_CHROME")?1:-1},function(e){if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+e+".")}),r.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",function(){return 128});var Ae="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",Fe=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=F.DENSE;var n=z(e),t=k();this.outputShape=e,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+g(["r","c","d"],e)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+n[0]+", "+n[1]+"));\n        int index = 4 * (resTexRC.x * "+n[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        "+t.output+" = result;\n      }\n    "},_e=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=F.DENSE;var n=z(e),t=k();this.outputShape=e,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        "+g(["r","c","d"],e)+"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2("+n[0]+", "+n[1]+"));\n        int index = 4 * (resTexRC.x * "+n[1]+" + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        "+t.output+" = result;\n      }\n    "},Oe=function(e){this.variableNames=["A"],this.outTexUsage=f.DOWNLOAD;var n=k();this.outputShape=e,this.userCode="\n      "+Ae+"\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+n.output+" = encode_float(x);\n      }\n    "},De=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=f.DOWNLOAD;var n=k();this.outputShape=e,this.userCode="\n      "+Ae+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        "+n.output+" = encode_float(x);\n      }\n    "},Le=function(e,n,t){void 0===t&&(t=!1),this.variableNames=["A"];var r=k(),a=n[0],n=n[1],i=(this.outputShape=e,"result");t&&(i="floor(result * 255. + 0.5)"),this.userCode="\n      "+Se(e)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / "+n+";\n        int c = imod(flatIndex, "+n+");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2("+n+".0, "+a+".0);\n        vec4 values = "+r.texture2D+"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        "+r.output+" = vec4("+i+", 0., 0., 0.);\n      }\n    "},Pe=function(e,n,t){void 0===t&&(t=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=k(),a=n[0],i=n[1],o=(this.outputShape=e,""),n="result";t&&(n="floor(result * 255. + 0.5)");for(var s=0;s<=1;s++)for(var u=0;u<=1;u++){var l=2*s+u;o+="\n          localCoords = coords;\n          if(localCoords[2] + "+u+" < "+e[2]+") {\n            localCoords[2] += "+u+";\n            if(localCoords[1] + "+s+" < "+e[1]+") {\n              localCoords[1] += "+s+";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / "+i+";\n              c = imod(flatIndex, "+i+");\n              uv = (vec2(c, r) + halfCR) / vec2("+i+".0, "+a+".0);\n              values = "+r.texture2D+"(A, uv);\n\n              if(offset == 0) {\n                result["+l+"] = values[0];\n              } else if(offset == 1) {\n                result["+l+"] = values[1];\n              } else if(offset == 2) {\n                result["+l+"] = values[2];\n              } else {\n                result["+l+"] = values[3];\n              }\n            }\n          }\n        "}this.userCode="\n      "+Se(e)+"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        "+o+"\n\n        "+r.output+" = "+n+";\n      }\n    "};function Be(e){var n=k();return q(e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function Ve(e){return te(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function We(e){return re(e,new Uint16Array([0,1,2,2,1,3]))}function Me(e,n,t,r,a,i){ie(n,t);var o=ae(e),s=e.TEXTURE_2D;return c(e,function(){return e.bindTexture(s,o)}),c(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)}),c(e,function(){return e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)}),c(e,function(){return e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST)}),c(e,function(){return e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST)}),c(e,function(){return e.texImage2D(s,0,r,n,t,0,a,i,null)}),c(e,function(){return e.bindTexture(e.TEXTURE_2D,null)}),o}function Ge(e){return e.internalFormatFloat}function Ue(e,n,t,r){t=[t,n];return Me(e,t[0],t[1],Ge(r),r.textureFormatFloat,e.FLOAT)}function ze(e){return e.internalFormatHalfFloat}function Xe(e,n,t,r){t=[t,n];return Me(e,t[0],t[1],ze(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function He(e){return e.downloadTextureFormat}function je(e,n,t,r){t=[t,n];return Me(e,t[0],t[1],He(r),e.RGBA,e.UNSIGNED_BYTE)}function Ke(e){return e.internalFormatPackedFloat}function qe(e,n,t,r){n=x(n,t);return Me(e,n[0],n[1],Ke(r),e.RGBA,e.FLOAT)}function Ye(e){return e.internalFormatPackedHalfFloat}function Qe(e,n,t,r){n=x(n,t);return Me(e,n[0],n[1],Ye(r),e.RGBA,r.textureTypeHalfFloat)}function Ze(e,n,t){return c(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,t)}),se(e,n,"clipSpacePos",t,3,20,0)&&se(e,n,"uv",t,2,20,12)}function $e(e,n,t,r,a,i){var o,s,u;c(e,function(){return e.bindTexture(e.TEXTURE_2D,n)}),u=a instanceof Uint8Array?(o=new Uint8Array(t*r*4),s=e.UNSIGNED_BYTE,e.RGBA):(o=new Float32Array(t*r*4),s=e.FLOAT,i.internalFormatPackedFloat),o.set(a),c(e,function(){return e.texImage2D(e.TEXTURE_2D,0,u,t,r,0,e.RGBA,s,o)}),c(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function Je(e,n,t){c(e,function(){return e.bindTexture(e.TEXTURE_2D,n)}),t.data instanceof Uint8Array?c(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t.data)}):c(e,function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t)}),c(e,function(){return e.bindTexture(e.TEXTURE_2D,null)})}function en(e,n,t,r){var a=e.createBuffer(),i=(c(e,function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,a)}),16*n*t);return c(e,function(){return e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)}),c(e,function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0)}),c(e,function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,null)}),a}function nn(e,n,t){t=new Float32Array(t);return e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,t),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),t}function tn(e,n,t,r){var a=[t,n],i=a[0],o=a[1],s=new Uint8Array(n*t*4);return c(e,function(){return e.readPixels(0,0,i,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,s)}),new Float32Array(s.buffer)}function rn(e,n,t,r,a,i,o,s){o=new Float32Array((i=x(i=i,o))[0]*i[1]*4);return e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,o),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),o}function an(e,n,t){var r=new Float32Array(n*t*4);return c(e,function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,r)}),r}var on={__proto__:null,createVertexShader:Be,createVertexBuffer:Ve,createIndexBuffer:We,getInternalFormatForFloat32MatrixTexture:Ge,createFloat32MatrixTexture:Ue,getInternalFormatForFloat16MatrixTexture:ze,createFloat16MatrixTexture:Xe,getInternalFormatForUnsignedBytesMatrixTexture:He,createUnsignedBytesMatrixTexture:je,getInternalFormatForPackedMatrixTexture:Ke,createPackedMatrixTexture:qe,getInternalFormatForFloat16PackedMatrixTexture:Ye,createFloat16PackedMatrixTexture:Qe,bindVertexProgramAttributeStreams:Ze,uploadDenseMatrixToTexture:$e,uploadPixelDataToTexture:Je,createBufferFromOutputTexture:en,downloadFloat32MatrixFromBuffer:nn,downloadByteEncodedFloatMatrixFromOutputTexture:tn,downloadPackedMatrixFromBuffer:rn,downloadMatrixFromPackedOutputTexture:an},sn=(Object.defineProperty(a.prototype,"debug",{get:function(){return D.env().getBool("DEBUG")},enumerable:!0,configurable:!0}),a.prototype.dispose=function(){var e,n=this;this.disposed||(null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing."),c(e=this.gl,function(){return e.finish()}),c(e,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),c(e,function(){return e.deleteFramebuffer(n.framebuffer)}),c(e,function(){return e.bindBuffer(e.ARRAY_BUFFER,null)}),c(e,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}),c(e,function(){return e.deleteBuffer(n.indexBuffer)}),this.disposed=!0)},a.prototype.createFloat32MatrixTexture=function(e,n){return this.throwIfDisposed(),Ue(this.gl,e,n,this.textureConfig)},a.prototype.createFloat16MatrixTexture=function(e,n){return this.throwIfDisposed(),Xe(this.gl,e,n,this.textureConfig)},a.prototype.createUnsignedBytesMatrixTexture=function(e,n){return this.throwIfDisposed(),je(this.gl,e,n,this.textureConfig)},a.prototype.uploadPixelDataToTexture=function(e,n){this.throwIfDisposed(),Je(this.gl,e,n)},a.prototype.uploadDenseMatrixToTexture=function(e,n,t,r){this.throwIfDisposed(),$e(this.gl,e,n,t,r,this.textureConfig)},a.prototype.createFloat16PackedMatrixTexture=function(e,n){return this.throwIfDisposed(),Qe(this.gl,e,n,this.textureConfig)},a.prototype.createPackedMatrixTexture=function(e,n){return this.throwIfDisposed(),qe(this.gl,e,n,this.textureConfig)},a.prototype.deleteMatrixTexture=function(e){var n=this;this.throwIfDisposed(),this.outputTexture===e&&(he(this.gl,this.framebuffer),this.outputTexture=null),c(this.gl,function(){return n.gl.deleteTexture(e)})},a.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(e,n,t){var r=this;return this.downloadMatrixDriver(e,function(){return tn(r.gl,n,t,r.textureConfig)})},a.prototype.downloadPackedMatrixFromBuffer=function(e,n,t,r,a,i){return rn(this.gl,e,0,0,0,a,i,this.textureConfig)},a.prototype.downloadFloat32MatrixFromBuffer=function(e,n){return nn(this.gl,e,n)},a.prototype.createBufferFromTexture=function(e,n,t){this.bindTextureToFrameBuffer(e);e=en(this.gl,n,t,this.textureConfig);return this.unbindTextureToFrameBuffer(),e},a.prototype.createAndWaitForFence=function(){var e=this.createFence(this.gl);return this.pollFence(e)},a.prototype.createFence=function(e){var n,t,r,a,i=this;return D.env().getBool("WEBGL_FENCE_API_ENABLED")?(a=(r=e).fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0),e.flush(),t=function(){var e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},n=a):t=0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(n=this.beginQuery(),this.endQuery(),function(){return i.isQueryAvailable(n,D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):function(){return!0},{query:n,isFencePassed:t}},a.prototype.downloadMatrixFromPackedTexture=function(e,n,t){var r=this;return this.downloadMatrixDriver(e,function(){return an(r.gl,n,t)})},a.prototype.createProgram=function(e){var n=this,t=(this.throwIfDisposed(),this.gl),r=Y(t,e),a=(null==this.vertexShader&&(this.vertexShader=Be(t)),J(t));return c(t,function(){return t.attachShader(a,n.vertexShader)}),c(t,function(){return t.attachShader(a,r)}),ee(t,a),this.debug&&ne(t,a),this.vertexAttrsAreBound||(this.setProgram(a),this.vertexAttrsAreBound=Ze(t,this.program,this.vertexBuffer)),a},a.prototype.deleteProgram=function(e){var n=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&c(this.gl,function(){return n.gl.deleteProgram(e)})},a.prototype.setProgram=function(e){var n=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&ne(this.gl,this.program),c(this.gl,function(){return n.gl.useProgram(e)})},a.prototype.getUniformLocation=function(e,n,t){return void 0===t&&(t=!0),this.throwIfDisposed(),(t?le:de)(this.gl,e,n)},a.prototype.getAttributeLocation=function(e,n){var t=this;return this.throwIfDisposed(),c(this.gl,function(){return t.gl.getAttribLocation(e,n)})},a.prototype.getUniformLocationNoThrow=function(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)},a.prototype.setInputMatrixTexture=function(e,n,t){this.throwIfDisposed(),this.throwIfNoProgram(),ce(this.gl,e,n,t)},a.prototype.setOutputMatrixTexture=function(e,n,t){this.setOutputMatrixTextureDriver(e,t,n)},a.prototype.setOutputPackedMatrixTexture=function(e,n,t){this.throwIfDisposed();n=x(n,t),t=n[0],n=n[1];this.setOutputMatrixTextureDriver(e,t,n)},a.prototype.setOutputMatrixWriteRegion=function(e,n,t,r){this.setOutputMatrixWriteRegionDriver(t,e,r,n)},a.prototype.setOutputPackedMatrixWriteRegion=function(e,n,t,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},a.prototype.debugValidate=function(){null!=this.program&&ne(this.gl,this.program),fe(this.gl)},a.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.debug&&this.debugValidate(),c(e,function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)})},a.prototype.blockUntilAllProgramsCompleted=function(){var e=this;this.throwIfDisposed(),c(this.gl,function(){return e.gl.finish()})},a.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=K(this.gl,2===D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},a.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},a.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},a.prototype.beginQuery=function(){var e,n,t;return 2===D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(n=this.gl,t=this.getQueryTimerExtensionWebGL2(),e=n.createQuery(),n.beginQuery(t.TIME_ELAPSED_EXT,e),e):(t=(n=this.getQueryTimerExtensionWebGL1()).createQueryEXT(),n.beginQueryEXT(n.TIME_ELAPSED_EXT,t),t)},a.prototype.endQuery=function(){var e,n;2===D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?(n=this.gl,e=this.getQueryTimerExtensionWebGL2(),n.endQuery(e.TIME_ELAPSED_EXT)):(n=this.getQueryTimerExtensionWebGL1()).endQueryEXT(n.TIME_ELAPSED_EXT)},a.prototype.waitForQueryAndGetTime=function(t){return S(this,void 0,void 0,function(){var n=this;return A(this,function(e){switch(e.label){case 0:return[4,D.util.repeatedTry(function(){return n.disposed||n.isQueryAvailable(t,D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return e.sent(),[2,this.getQueryTime(t,D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},a.prototype.getQueryTime=function(e,n){return 0===n?null:2===n?(n=this.gl).getQueryParameter(e,n.QUERY_RESULT)/1e6:(n=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6},a.prototype.isQueryAvailable=function(e,n){var t;return 0===n||(n=2===n?(n=this.gl,t=this.getQueryTimerExtensionWebGL2(),n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE)):(t=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT),null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint)},a.prototype.pollFence=function(n){var t=this;return new Promise(function(e){t.addItemToPoll(function(){return n.isFencePassed()},function(){return e()})})},a.prototype.pollItems=function(){for(var e=function(e){for(var n=0;n<e.length;++n)if(!e[n]())break;return n-1}(this.itemsToPoll.map(function(e){return e.isDoneFn})),n=0;n<=e;++n)(0,this.itemsToPoll[n].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(e+1)},a.prototype.addItemToPoll=function(e,n){var t=this;this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),1<this.itemsToPoll.length||D.util.repeatedTry(function(){return t.pollItems(),0===t.itemsToPoll.length})},a.prototype.bindTextureToFrameBuffer=function(e){this.throwIfDisposed(),pe(this.gl,e,this.framebuffer),this.debug&&fe(this.gl)},a.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(pe(this.gl,this.outputTexture,this.framebuffer),this.debug&&fe(this.gl)):he(this.gl,this.framebuffer)},a.prototype.downloadMatrixDriver=function(e,n){this.bindTextureToFrameBuffer(e);e=n();return this.unbindTextureToFrameBuffer(),e},a.prototype.setOutputMatrixTextureDriver=function(e,n,t){this.throwIfDisposed();var r=this.gl;pe(r,e,this.framebuffer),this.debug&&fe(r),this.outputTexture=e,c(r,function(){return r.viewport(0,0,n,t)}),c(r,function(){return r.scissor(0,0,n,t)})},a.prototype.setOutputMatrixWriteRegionDriver=function(e,n,t,r){var a=this;this.throwIfDisposed(),c(this.gl,function(){return a.gl.scissor(e,n,t,r)})},a.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},a.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},a);function a(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var n=D.env().getNumber("WEBGL_VERSION"),e=(null!=e?G(n,this.gl=e):this.gl=i(n),"EXT_color_buffer_half_float");if(1===D.env().getNumber("WEBGL_VERSION")){var n="OES_texture_half_float";if(this.textureFloatExtension=K(this.gl,"OES_texture_float"),s(this.gl,n))this.textureHalfFloatExtension=K(this.gl,n);else if(D.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),s(this.gl,e))this.colorBufferHalfFloatExtension=K(this.gl,e);else if(D.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s(this.gl,n="EXT_color_buffer_float"))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!s(this.gl,e))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(e)}this.vertexBuffer=Ve(this.gl),this.indexBuffer=We(this.gl),this.framebuffer=oe(this.gl),this.textureConfig=X(this.gl,this.textureHalfFloatExtension)}var un=D.backend_util.getBroadcastDims;function ln(e,o,n,s){var t,r=[],a=(e.forEach(function(e){var n=D.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?r.push("uniform float "+e.name+(1<n?"["+n+"]":"")+";"):(r.push("uniform sampler2D "+e.name+";"),r.push("uniform int offset"+e.name+";"))}),r.join("\n")),e=e.map(function(e){var n=o,t=s,r="",a=(r+=((t=void 0===t?!1:t)?dn:L)(e),e.shapeInfo.logicalShape),i=n.logicalShape;return a.length<=i.length&&(r+=(t?function(e,n){var t,r=e.name,r=r.charAt(0).toUpperCase()+r.slice(1),a="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=n.logicalShape.length,s=un(e.shapeInfo.logicalShape,n.logicalShape),u=m(o),l=o-i,d=["x","y","z","w","u","v"];t=0===i?"":o<2&&1<=s.length?"coords = 0;":s.map(function(e){return"coords."+d[e+l]+" = 0;"}).join("\n");var c="";c=o<2&&0<i?"coords":e.shapeInfo.logicalShape.map(function(e,n){return"coords."+d[n+l]}).join(", ");var p="return outputValue;",e=1===D.util.sizeFromShape(e.shapeInfo.logicalShape),n=1===D.util.sizeFromShape(n.logicalShape);1!==i||e||n?e&&!n?p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ":s.length&&(e=i-2,n=i-1,-1<s.indexOf(e)&&-1<s.indexOf(n)?p="return vec4(outputValue.x);":-1<s.indexOf(e)?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":-1<s.indexOf(n)&&(p="return vec4(outputValue.xx, outputValue.zz);")):p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+u+" coords = getOutputCoords();\n      "+t+"\n      vec4 outputValue = get"+r+"("+c+");\n      "+p+"\n    }\n  "}:function(e,n){var t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),a="get"+r+"AtOutCoords",i=n.texShape,o=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!e.shapeInfo.isUniform&&s===u&&null==e.shapeInfo.flatOffset&&D.util.arraysEqual(o,i))return"\n      float "+a+"() {\n        return sampleTexture("+t+", resultUV);\n      }\n    ";var o=m(u),i=un(e.shapeInfo.logicalShape,n.logicalShape),l=u-s,d=["x","y","z","w","u","v"];t=0===s?"":u<2&&1<=i.length?"coords = 0;":i.map(function(e){return"coords."+d[e+l]+" = 0;"}).join("\n");n="";n=u<2&&0<s?"coords":e.shapeInfo.logicalShape.map(function(e,n){return"coords."+d[n+l]}).join(", ");return"\n    float "+a+"() {\n      "+o+" coords = getOutputCoords();\n      "+t+"\n      return get"+r+"("+n+");\n    }\n  "})(e,n)),r}).join("\n"),i=o.texShape,u=k(),l="\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+u.texture2D+"(textureSampler, uv).r;\n    }\n  ",d=u.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+u.varyingFs+" vec2 resultUV;\n    "+u.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    "+u.defineSpecialNaN+"\n    "+u.defineSpecialInf+"\n    "+u.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+cn+"\n    "+pn+"\n    "+hn+"\n  ",i=o.isPacked?(t=function(e,n){switch(e.length){case 0:return xn();case 1:return function(e){e=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1!==e[0]?1!==e[1]?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return 2 * (resTexRC.x * "+e[1]+" + resTexRC.y);\n    }\n  ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+e[0]+".0);\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+e[1]+".0);\n      }\n    "}(n);case 2:return function(e,n){var t=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(D.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+t[0]+", "+t[1]+"));\n      }\n    ";n=Math.ceil(e[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+t[0]+", "+t[1]+"));\n\n      int index = resTexRC.x * "+t[1]+" + resTexRC.y;\n      int r = 2 * (index / "+n+");\n      int c = imod(index, "+n+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(e,n);case 3:return function(e,n){var n=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],t=Math.ceil(e[2]/2),e=t*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      int b = index / "+e+";\n      index -= b * "+e+";\n\n      int r = 2 * (index / "+t+");\n      int c = imod(index, "+t+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  "}(e,n);default:return function(e,n){for(var n=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],t=Math.ceil(e[e.length-1]/2),r=t*Math.ceil(e[e.length-2]/2),a=r,i="",o="b, r, c",s=2;s<e.length-1;s++)a*=e[e.length-s-1],i="\n      int b"+s+" = index / "+a+";\n      index -= b"+s+" * "+a+";\n    "+i,o="b"+s+", "+o;return"\n    ivec"+e.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+r+";\n      index -= b * "+r+";\n\n      int r = 2 * (index / "+t+");\n      int c = imod(index, "+t+") * 2;\n\n      return ivec"+e.length+"("+o+");\n    }\n  "}(e,n)}}(o.logicalShape,i),"\n    void setOutput(vec4 val) {\n      "+u.output+" = val;\n    }\n  "):(t=function(e,n){switch(e.length){case 0:return xn();case 1:return function(e){return 1!==e[0]?1!==e[1]?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  ":"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    "}(n);case 2:return function(e,n){if(D.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";return 1!==e[1]?1!==e[0]?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = index / "+e[1]+";\n      int c = index - r * "+e[1]+";\n      return ivec2(r, c);\n    }\n  ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+n[0]+", "+n[1]+"));\n        int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "}(e,n);case 3:return function(e,n){e=g(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+e+"\n      return ivec3(r, c, d);\n    }\n  "}(e,n);case 4:return function(e,n){e=g(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+e+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(e,n);case 5:return function(e,n){e=g(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+n[0]+",\n                             "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+e+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(e,n);case 6:return function(e,n){e=g(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+e+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(e,n);default:throw new Error(e.length+"-D output sampling is not yet supported")}}(o.logicalShape,i),"\n    void setOutput(float val) {\n      "+u.output+" = vec4(val, 0, 0, 0);\n    }\n  ");return s&&(d+=fn),[d,l,i,a,t,e,n].join("\n")}function L(e){var n=e.shapeInfo.logicalShape;switch(n.length){case 0:var t=e,r=t.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1);return t.shapeInfo.isUniform?"float "+a+"() {return "+r+";}":(i=(o=t.shapeInfo.texShape)[0],o=o[1],1===i&&1===o?"\n      float "+a+"() {\n        return sampleTexture("+r+", halfCR);\n      }\n    ":(i=t.shapeInfo.texShape,o=i[0],t=i[1],i=P(r),"\n    float "+a+"() {\n      vec2 uv = uvFromFlat("+o+", "+t+", "+i+");\n      return sampleTexture("+r+", uv);\n    }\n  "));case 1:var i,o=(a=e).name,t="get"+o.charAt(0).toUpperCase()+o.slice(1);return a.shapeInfo.isUniform?"\n      float "+t+"(int index) {\n        "+B(a)+"\n      }\n    ":(i=(a=a.shapeInfo.texShape)[0],1===(a=a[1])&&1===i?"\n      float "+t+"(int index) {\n        return sampleTexture("+o+", halfCR);\n      }\n    ":(r=P(o),1!==a?1!==i?"\n    float "+t+"(int index) {\n      vec2 uv = uvFromFlat("+i+", "+a+", index + "+r+");\n      return sampleTexture("+o+", uv);\n    }\n  ":"\n      float "+t+"(int index) {\n        vec2 uv = vec2((float(index + "+r+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+o+", uv);\n      }\n    ":"\n      float "+t+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+r+") + 0.5) / "+i+".0);\n        return sampleTexture("+o+", uv);\n      }\n    "));case 2:var s=e,u=s.shapeInfo.logicalShape,l=s.name,d="get"+l.charAt(0).toUpperCase()+l.slice(1),c=s.shapeInfo.texShape;return null!=c&&D.util.arraysEqual(u,c)?(h=c[0],p=c[1],"\n    float "+d+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+p+".0, "+h+".0);\n      return sampleTexture("+l+", uv);\n    }\n  "):(h=(p=D.util.squeezeShape(u)).newShape,p=p.keptDims,h.length<u.length?"\n      "+L(h=V(s,h))+"\n      float "+d+"(int row, int col) {\n        return "+d+"("+W(["row","col"],p)+");\n      }\n    ":s.shapeInfo.isUniform?"\n      float "+d+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+u[1]+", 1)));\n        "+B(s)+"\n      }\n    ":(h=c[0],p=c[1],s=P(l),1!==p?1!==h?"\n  float "+d+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+u[1]+" + col + "+s+";\n    vec2 uv = uvFromFlat("+h+", "+p+", index);\n    return sampleTexture("+l+", uv);\n  }\n":"\n    float "+d+"(int row, int col) {\n      float index = dot(vec3(row, col, "+s+"), vec3("+u[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+p+".0, 0.5);\n      return sampleTexture("+l+", uv);\n    }\n  ":"\n    float "+d+"(int row, int col) {\n      float index = dot(vec3(row, col, "+s+"), vec3("+u[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+h+".0);\n      return sampleTexture("+l+", uv);\n    }\n  "));case 3:var c=e,p=c.shapeInfo.logicalShape,d=c.name,s="get"+d.charAt(0).toUpperCase()+d.slice(1),u=p[1]*p[2],h=p[2],f=(l=D.util.squeezeShape(p)).newShape,l=l.keptDims;return f.length<p.length?"\n        "+L(f=V(c,f))+"\n        float "+s+"(int row, int col, int depth) {\n          return "+s+"("+W(["row","col","depth"],l)+");\n        }\n      ":c.shapeInfo.isUniform?"\n      float "+s+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+u+", "+h+", 1)));\n        "+B(c)+"\n      }\n    ":(f=c.shapeInfo.texShape,l=f[0],f=f[1],c=c.shapeInfo.flatOffset,f===u&&null==c?"\n        float "+s+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+h+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+f+".0, "+l+".0);\n          return sampleTexture("+d+", uv);\n        }\n      ":f===h&&null==c?"\n    float "+s+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+p[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+f+".0, "+l+".0);\n      return sampleTexture("+d+", uv);\n    }\n  ":(c=P(d),"\n      float "+s+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+u+" + col * "+h+" + depth + "+c+";\n        vec2 uv = uvFromFlat("+l+", "+f+", index);\n        return sampleTexture("+d+", uv);\n      }\n  "));case 4:var f=e,x=f.shapeInfo.logicalShape,g=f.name,m="get"+g.charAt(0).toUpperCase()+g.slice(1),v=x[3],b=x[2]*v,C=x[1]*b,y=(k=D.util.squeezeShape(x)).newShape,k=k.keptDims;return y.length<x.length?"\n      "+L(y=V(f,y))+"\n      float "+m+"(int row, int col, int depth, int depth2) {\n        return "+m+"("+W(["row","col","depth","depth2"],k)+");\n      }\n    ":f.shapeInfo.isUniform?"\n      float "+m+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+C+", "+b+", "+v+", 1)));\n        "+B(f)+"\n      }\n    ":(y=f.shapeInfo.flatOffset,k=f.shapeInfo.texShape,f=k[0],(k=k[1])===C&&null==y?"\n      float "+m+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+b+", "+v+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+k+".0, "+f+".0);\n        return sampleTexture("+g+", uv);\n      }\n    ":k===v&&null==y?"\n      float "+m+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+x[1]*x[2]+", "+x[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+k+".0, "+f+".0);\n        return sampleTexture("+g+", uv);\n      }\n    ":(y=P(g),"\n    float "+m+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+C+" + col * "+b+" +\n          depth * "+v+" + depth2;\n      vec2 uv = uvFromFlat("+f+", "+k+", index + "+y+");\n      return sampleTexture("+g+", uv);\n    }\n  "));case 5:var x=e,m=x.shapeInfo.logicalShape,C=x.name,b="get"+C.charAt(0).toUpperCase()+C.slice(1),v=m[4],k=m[3]*v,y=m[2]*k,g=m[1]*y,I=(w=D.util.squeezeShape(m)).newShape,w=w.keptDims;return I.length<m.length?"\n      "+L(I=V(x,I))+"\n      float "+b+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+b+"("+W(["row","col","depth","depth2","depth3"],w)+");\n      }\n    ":x.shapeInfo.isUniform?"\n      float "+b+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+g+", "+y+", "+k+", "+v+")) +\n          depth3;\n        "+B(x)+"\n      }\n    ":(I=x.shapeInfo.flatOffset,w=x.shapeInfo.texShape,x=w[0],(w=w[1])===g&&null==I?"\n      float "+b+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+y+", "+k+", "+v+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+w+".0, "+x+".0);\n        return sampleTexture("+C+", uv);\n      }\n    ":w===v&&null==I?"\n      float "+b+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+m[1]*m[2]*m[3]+",\n               "+m[2]*m[3]+", "+m[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+w+".0, "+x+".0);\n        return sampleTexture("+C+", uv);\n      }\n    ":(I=P(C),"\n    float "+b+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+g+" + col * "+y+" + depth * "+k+" +\n          depth2 * "+v+" + depth3 + "+I+";\n      vec2 uv = uvFromFlat("+x+", "+w+", index);\n      return sampleTexture("+C+", uv);\n    }\n  "));case 6:var R,T,N,E,S,I=e,w=I.shapeInfo.logicalShape,A=I.name,F="get"+A.charAt(0).toUpperCase()+A.slice(1),_=(O=D.util.squeezeShape(w)).newShape,O=O.keptDims;return _.length<w.length?"\n      "+L(_=V(I,_))+"\n      float "+F+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+F+"("+W(["row","col","depth","depth2","depth3","depth4"],O)+");\n      }\n    ":(_=w[5],O=w[4]*_,R=w[3]*O,T=w[2]*R,N=w[1]*T,I.shapeInfo.isUniform?"\n      float "+F+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+N+", "+T+", "+R+", "+O+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+_+", 1)));\n        "+B(I)+"\n      }\n    ":(E=I.shapeInfo.flatOffset,S=(I=I.shapeInfo.texShape)[0],(I=I[1])===N&&null==E?"\n      float "+F+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+T+", "+R+", "+O+", "+_+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+I+".0, "+S+".0);\n        return sampleTexture("+A+", uv);\n      }\n    ":I===_&&null==E?"\n      float "+F+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+w[1]*w[2]*w[3]*w[4]+",\n               "+w[2]*w[3]*w[4]+",\n               "+w[3]*w[4]+",\n               "+w[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+I+".0, "+S+".0);\n        return sampleTexture("+A+", uv);\n      }\n    ":(E=P(A),"\n    float "+F+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+N+" + col * "+T+" + depth * "+R+" +\n          depth2 * "+O+" + depth3 * "+_+" + depth4 + "+E+";\n      vec2 uv = uvFromFlat("+S+", "+I+", index);\n      return sampleTexture("+A+", uv);\n    }\n  ")));default:throw new Error(n.length+"-D input sampling is not yet supported")}}function dn(e){var n,t,r;switch(e.shapeInfo.logicalShape.length){case 0:return n=(n=e).name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),r=k(),"\n    vec4 "+t+"() {\n      return "+r.texture2D+"("+n+", halfCR);\n    }\n  ";case 1:return r=(t=e).name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),t=t.shapeInfo.texShape,t=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=k(),"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+t[0]+", "+t[1]+", index);\n      return "+a.texture2D+"("+r+", uv);\n    }\n  ";case 2:var a=e,i=a.shapeInfo.logicalShape,o=a.name,s="get"+o.charAt(0).toUpperCase()+o.slice(1),u=(a=a.shapeInfo.texShape)[0],l=a[1],d=k();return null!=a&&D.util.arraysEqual(i,a)?"\n      vec4 "+s+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+l+".0, "+u+".0);\n\n        return "+d.texture2D+"("+o+", uv);\n      }\n    ":(l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=Math.ceil(i[1]/2),"\n    vec4 "+s+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+u+", "+l[0]+", "+l[1]+", row, col);\n      return "+d.texture2D+"("+o+", uv);\n    }\n  ");case 3:i=e,s=i.shapeInfo.logicalShape,u=i.name,l="get"+u.charAt(0).toUpperCase()+u.slice(1),d=i.shapeInfo.texShape,d=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)];return 1===s[0]?(x=s.slice(1),"\n        "+dn(i=V(i,x))+"\n        vec4 "+l+"(int b, int row, int col) {\n          return "+l+"("+W(["b","row","col"],[1,2])+");\n        }\n      "):(x=d[0],i=d[1],s=(d=Math.ceil(s[2]/2))*Math.ceil(s[1]/2),o=k(),"\n    vec4 "+l+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+x+", "+i+", "+s+", "+d+", b, row, col);\n      return "+o.texture2D+"("+u+", uv);\n    }\n  ");default:for(var c=(x=e).shapeInfo.logicalShape,p=c.length,h=x.name,f="get"+h.charAt(0).toUpperCase()+h.slice(1),x=x.shapeInfo.texShape,g=(x=[Math.ceil(x[0]/2),Math.ceil(x[1]/2)])[0],x=x[1],m=Math.ceil(c[p-1]/2),v=m*Math.ceil(c[p-2]/2),b="int b, int row, int col",C="b * "+v+" + (row / 2) * "+m+" + (col / 2)",y=2;y<p-1;y++)b="int b"+y+", "+b,v*=c[p-y-1],C="b"+y+" * "+v+" + "+C;return m=k(),"\n    vec4 "+f+"("+b+") {\n      int index = "+C+";\n      int texR = index / "+x+";\n      int texC = index - texR * "+x+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+x+", "+g+");\n      return "+m.texture2D+"("+h+", uv);\n    }\n  "}}var cn="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",pn="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",hn="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",fn="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xn(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function P(e){return"offset"+e}function B(e){var n=e.name,e=D.util.sizeFromShape(e.shapeInfo.logicalShape);return e<2?"return "+n+";":"\n    for (int i = 0; i < "+e+"; i++) {\n      if (i == index) {\n        return "+n+"[i];\n      }\n    }\n  "}function m(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank "+e+" is not yet supported")}function V(e,n){e=JSON.parse(JSON.stringify(e));return e.shapeInfo.logicalShape=n,e}function W(n,e){return e.map(function(e){return n[e]}).join(", ")}function gn(e,a){if(e.length!==a.length)throw Error("Binary was compiled with "+e.length+" inputs, but was executed with "+a.length+" inputs");e.forEach(function(e,n){var t=e.logicalShape,n=a[n],r=n.shape;if(!D.util.arraysEqual(t,r))throw Error("Binary was compiled with different shapes than the current args. Shapes "+t+" and "+r+" must match");if(!e.isUniform||!n.isUniform){t=e.texShape,r=n.isUniform?null:n.texData.texShape;if(!D.util.arraysEqual(t,r))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+t+" and "+r+" must match")}})}function l(C){return(e,n,t,r,a)=>{var i=D.backend_util.assertAndGetBroadcastShape(e,n),o=i.length,s=D.util.computeStrides(i),u=D.util.sizeFromShape(i),l=D.util.getTypedArrayFromDType(a,u),d=e.length,c=n.length,p=D.util.computeStrides(e),h=D.util.computeStrides(n),f=D.backend_util.getBroadcastDims(e,i),x=D.backend_util.getBroadcastDims(n,i);if(f.length+x.length===0)for(let e=0;e<l.length;++e)l[e]=C(t[e%t.length],r[e%r.length]);else for(let e=0;e<l.length;++e){var g=D.util.indexToLoc(e,o,s);const v=g.slice(-d);f.forEach(e=>v[e]=0);var m=D.util.locToIndex(v,d,p);const b=g.slice(-c);x.forEach(e=>b[e]=0);g=D.util.locToIndex(b,c,h);l[e]=C(t[m],r[g])}return[l,i]}}var mn=l((e,n)=>e+n);function vn(a){return(n,e,t)=>{var r=D.util.getTypedArrayFromDType(e,n.length);for(let e=0;e<n.length;++e)r[e]=a(n[e],t);return r}}var bn=vn(e=>Math.ceil(e));var Cn=l((e,n)=>e===n?1:0),yn=vn(e=>Math.exp(e)),kn=vn(e=>Math.expm1(e)),In=vn(e=>Math.floor(e));var wn=l((e,n)=>n<e?1:0),Rn=l((e,n)=>n<=e?1:0),Tn=l((e,n)=>e<n?1:0),Nn=l((e,n)=>e<=n?1:0);var En=vn(e=>Math.log(e));var Sn=l((e,n)=>Math.max(e,n)),An=l((e,n)=>Math.min(e,n));const Fn=l((e,n)=>e*n);var _n=l((e,n)=>e!==n?1:0);var On=vn(e=>1/Math.sqrt(e));class Dn{constructor(e,n,t,r,a,i){this.separator=D.util.encodeString(e),this.nGramWidths=n,this.leftPad=D.util.encodeString(t),this.rightPad=D.util.encodeString(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){var t=this.getPadWidth(n);return Math.max(0,e+2*t-n+1)}createNGrams(r,a,i,o,s,u){for(let e=0;e<s;++e){var l=this.getPadWidth(u),d=Math.max(0,l-e),c=Math.max(0,l-(s-(e+1))),p=u-(d+c),h=a+(0<d?0:e-l);let n=0;n+=d*this.leftPad.length;for(let e=0;e<p;++e)n+=r[h+e].length;n=(n+=c*this.rightPad.length)+(d+c+p-1)*this.separator.length,i[o+e]=new Uint8Array(n);const x=i[o+e];let t=0;var f=e=>e.forEach(e=>x[t++]=e);for(let e=0;e<d;++e)f(this.leftPad),f(this.separator);for(let e=0;e<p-1;++e)f(r[h+e]),f(this.separator);if(0<p){f(r[h+p-1]);for(let e=0;e<c;++e)f(this.separator),f(this.rightPad)}else{for(let e=0;e<c-1;++e)f(this.rightPad),f(this.separator);f(this.rightPad)}}}compute(a,i){var t=a.length,r=i.length;if(0<r){let n=i[0];if(0!==n)throw new Error("First split value must be 0, got "+n);for(let e=1;e<r;++e){if(!(i[e]>=n&&i[e]<=t))throw new Error(`Invalid split value ${i[e]}, must be in [${n}, ${t}]`);n=i[e]}if(n!==t)throw new Error(`Last split value must be data size. Expected ${t}, got `+n)}var e,n=r-1,o=D.util.getArrayFromDType("int32",r);if(0===t||0===r){var s=new Array(t);for(let e=0;e<=n;++e)o[e]=0;return[s,o]}o[0]=0;for(let e=1;e<=n;++e){const l=i[e]-i[e-1];let n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(l,e)}),this.preserveShort&&0<l&&0===n&&(n=1),o[e]=o[e-1]+n}const u=new Array(o[n]);for(let r=0;r<n;++r){const d=i[r];let t=o[r];this.nGramWidths.forEach(e=>{var n=i[r+1]-i[r],n=this.getNumNGrams(n,e);this.createNGrams(a,d,u,t,n,e),t+=n}),this.preserveShort&&t===o[r]&&0!=(e=i[r+1]-i[r])&&(e=e+2*this.padWidth,this.createNGrams(a,d,u,t,1,e))}return[u,o]}}var Ln=l((e,n)=>e-n);var Pn=function(n,t,e,r,a){var i=D.util.sizeFromShape(r),o=D.util.makeZerosTypedArray(a,e);for(let e=0;e<n.length;e++){var s=n[e];if(s<0)throw new Error("Input x must be non-negative!");a<=s||(o[s]+=0<i?t[e]:1)}return o},Bn=function(t,r,a,i=!1){var e=t.shape[0],o=t.shape[1],s=D.buffer([e,a],r.dtype);for(let n=0;n<e;n++)for(let e=0;e<o;e++){var u=t.get(n,e);if(u<0)throw new Error("Input x must be non-negative!");a<=u||(i?s.set(1,n,u):0<r.size?s.set(s.get(n,u)+r.get(n,e),n,u):s.set(s.get(n,u)+1,n,u))}return s},Vn=function(e,o,s,n){const u=D.util.getArrayFromDType(s,D.util.sizeFromShape(o));if(n&&"string"!==s){let t=0;e.forEach(e=>{var n=D.util.sizeFromShape(e.shape);u.set(e.vals,t),t+=n})}else{let i=0;e.forEach(n=>{var t="string"===s?D.backend_util.fromUint8ToStringArray(n.vals):n.vals;let r=0;for(let e=0;e<n.shape[0];++e){var a=e*o[1]+i;for(let e=0;e<n.shape[1];++e)u[a+e]=t[r++]}i+=n.shape[1]})}return u},Wn=function(r,a,e,n,i,o,s,u,l){var d=D.buffer([n,o],e);for(let t=0;t<n;t++){var c=[];let n=0;for(let e=0;e<i;e++){var p=r[t*i+e];n+=p*s[e],c.push(p)}if(n<0||n>=l/o)throw new Error(`Invalid indices: ${c} does not index into `+u);for(let e=0;e<o;e++)d.values[t*o+e]=a.get(...a.indexToLoc(n*o+e))}return d},Mn=function(n,t,e){var r=D.buffer(e,n.dtype);for(let e=0;e<r.size;++e){var a=r.indexToLoc(e).slice(),i=a[0],o=a[2],i=t.locToIndex([i,o]),o=(a[2]=t.values[i],n.locToIndex(a));r.values[e]=n.values[o]}return r},Gn=function(e,n,t){var r=(n-e)/(t-1),a=D.util.makeZerosTypedArray(t,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a},Un=function(t,r,e,n){var a=D.util.getTypedArrayFromDType(n,D.util.sizeFromShape(e));for(let e=0;e<a.length;++e){var i=e*r;let n=t[i];for(let e=0;e<r;++e){var o=t[i+e];(Number.isNaN(o)||o>n)&&(n=o)}a[e]=n}return a},zn=Fn,Xn=function(e,n,t){var r=D.util.createScalarValue(-1,t);return Fn([],n,r,e,t)},Hn=function(e,n,t,r){var[e,r]=D.backend_util.computeOutAndReduceShapes(e,r),n=D.upcastType(n,"int32"),a=D.util.makeZerosTypedArray(D.util.sizeFromShape(e),n),i=D.util.sizeFromShape(r);for(let e=0;e<a.length;++e){var o=e*i;let n=1;for(let e=0;e<i;++e)n*=t[o+e];a[e]=n}return{outVals:a,outShape:e,outDtype:n}},jn=function(e,n,t,r){if(e===n||e<n&&t<0||n<e&&1<t)return D.util.makeZerosTypedArray(0,r);var a=Math.abs(Math.ceil((n-e)/t)),i=D.util.makeZerosTypedArray(a,r);n<e&&1===t&&(t=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+t;return i},Kn=function(n){var t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t},qn=function(e,t,n,r,a){var i=D.slice_util.isSliceContinous(r,t,n),o=D.util.sizeFromShape(n),s=D.util.computeStrides(r);if(i)return i=D.slice_util.computeFlatOffset(t,s),"string"===a?e.slice(i,i+o):e.subarray(i,i+o);var s="string"===a?D.backend_util.fromUint8ToStringArray(e):e,u=D.buffer(r,a,s),l=D.buffer(n,a);for(let e=0;e<l.size;++e){var d=l.indexToLoc(e),c=d.map((e,n)=>e+t[n]);l.set(u.get(...c),...d)}return"string"===a?D.backend_util.fromStringArrayToUint8(l.values):l.values},Yn=function(t,e,n,r,a,i,o){var s=e[0],u=i[0],l=new Array(u),d=new Array(s),c=e[1];if(0===u){if(0!==s)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = `+s);return[D.util.getArrayFromDType(n,0),[0,c],D.util.getArrayFromDType(a,0),l,d]}let p=!0,h=0;var f=new Array(u).fill(0);for(let e=0;e<s;++e){var x=t[e*c];if(x<0)throw new Error(`indices(${e}, 0) is invalid: ${x} < 0`);if(u<=x)throw new Error(`indices(${e}, 0) is invalid: ${x} >= `+u);++f[x],p=p&&x>=h,h=x}let g=!0;for(let e=0;e<u;++e){var m=0===f[e];l[e]=m,g=g&&!m,f[e]=Math.max(f[e],1),0<e&&(f[e]+=f[e-1])}if(g&&p){i=t,e=r;for(let e=0;e<s;++e)d[e]=e;return[i,[s,c],e,l,d]}var i=f[u-1],v=D.util.getArrayFromDType(n,i*c),b=D.util.getArrayFromDType(a,i),C=new Array(u).fill(0);for(let n=0;n<s;++n){var y=t[n*c],k=C[y],I=(0===y?0:f[y-1])+k;C[y]++;for(let e=0;e<c;++e)v[I*c+e]=t[n*c+e];b[I]=r[n],d[n]=I}for(let e=0;e<u;++e)if(0===C[e]){var w=0===e?0:f[e-1];v[w*c+0]=e;for(let e=1;e<c;++e)v[w*c+e]=0;b[w]=o}return[v,[i,c],b,l,d]},Qn=function(r,e,n,t,a){var i=D.util.sizeFromShape(t),o=e[0],s=a.length,u=[];let l=1,d=-1;for(let e=0;e<s;++e){var c=a[e];if(-1===c){if(-1!==d)throw new Error(`only one output dimension may be -1, not both ${d} and `+e);d=e,u.push(1)}else{if(c<0)throw new Error(`size ${e} must be non-negative, not `+c);l*=c,u.push(c)}}if(-1!==d){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");e=Math.trunc(i/l);if(l*e!==i)throw new Error(`Input to reshape is a SparseTensor with ${i}
          dense values, but the requested shape requires a multiple of ${l}. inputShape=${t} outputShape= `+u);u[d]=e}if((e=D.util.sizeFromShape(u))!==i)throw new Error(`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${e}. inputShape=${t} outputShape=`+u);var p=t.length,h=[];if(0<p){h[p-1]=1;for(let e=p-2;0<=e;--e)h[e]=h[e+1]*t[e+1]}var f=[];if(0<s){f[s-1]=1;for(let e=s-2;0<=e;--e)f[e]=f[e+1]*u[e+1]}var x=D.util.getArrayFromDType(n,o*s);for(let t=0;t<o;++t){let n=0;for(let e=0;e<p;++e)n+=r[t*p+e]*h[e];for(let e=0;e<s;++e)x[t*s+e]=Math.trunc(n/f[e]),n%=f[e]}return[x,[o,s],u]},Zn=function(i,e,n,o,s,u=!1,l=0){var d=o.length;if(d!==s.length)throw new Error("segmentIds and indices should have same size.");var c=[e[0],i.length/e[0]],p=c[1],h=0<d?s[d-1]+1:0;if(h<0)throw new Error("segment ids must be >= 0");(e=e.slice())[0]=h;var t=e.reduce((e,n)=>e*n,1),f=D.util.getArrayFromDType(n,t);if(0===d)0<h&&f.fill(l);else{if(h<=0)throw new Error("segment ids must be >= 0");let n=0,t=1,r=0,a=s[n];for(;;){let e=0;if(t<d){if(e=s[t],a===e){++t;continue}if(a>=e)throw new Error("segment ids are not increasing")}if(a<0||a>=h)throw new Error(`Segment id ${a} out of range [0, ${h}), possibly because segmentIds input is not sorted.`);a>r&&f.fill(l,r*p,a*p);for(let e=n;e<t;++e){var x=o[e];if(x<0||c[0]<=x)throw new Error(`Bad: indices[${e}] == ${o[e]} out of range [0, ${c[0]})`);for(let e=0;e<p;e++)f[a*p+e]+=i[x*p+e]}if(u)for(let e=0;e<p;e++)f[a*p+e]/=t-n;if(n=t,++t,r=a+1,a=e,t>d)break}r<h&&f.fill(l,r*p,h*p)}return[f,e]},$n=function(e,n,t,r){var a=D.buffer(e,n.dtype);for(let e=0;e<a.size;e++){var i=a.indexToLoc(e),o=new Array(i.length);for(let e=0;e<o.length;e++)o[e]=i[e]*t[e]+r[e];a.set(n.get(...o),...i)}return a},Jn=function(e,n,t,r,a,i,o,s){return new Dn(t,r,a,i,o,s).compute(e,n)},et=function(n,t,r){var a=n.length,i=[];let o=0,s=0;var u=new Array(a);for(let e=0;e<a;++e){var l=function(n,t,r){if(!n.length)return[];if(0===t.length){const o=new Array(n.length);for(let e=0;e<n.length;++e)o[e]=n.subarray(e,e+1);return o}if(1===t.length){var a=t[0];const o=[];let e=n.indexOf(a);for(;-1!==e;){var i=n.subarray(0,e);r&&0===i.length||o.push(i),n=n.subarray(e+1),e=n.indexOf(a)}return r&&0===n.length||o.push(n),o}const o=[];let s=0;for(let e=0;e<n.length+1;e++){var u;e!==n.length&&-1===t.indexOf(n[e])||(u=n.subarray(s,e),r&&0===u.length||o.push(u),s=e+1)}return o}(n[e],t,r),d=l.length;u[e]=d,o+=d,s=Math.max(s,d),i.push(...l)}var c=D.util.getArrayFromDType("int32",2*o),p=new Array(o),e=[a,s];let h=0;for(let n=0;n<a;++n)for(let e=0;e<u[n];++e)c[2*h]=n,c[2*h+1]=e,p[h]=i[h],++h;return[c,p,e]},nt=function(n,t){var r=D.util.getArrayFromDType("int32",n.length);for(let e=0;e<n.length;++e)r[e]=D.util.fingerPrint64(n[e]).modulo(t).getLowBitsUnsigned();return r},tt=function(n,t){var r=new Array(n.rank);for(let e=0;e<r.length;e++)r[e]=n.shape[e]*t[e];var a=D.buffer(r,n.dtype);for(let e=0;e<a.values.length;++e){var i=a.indexToLoc(e),o=new Array(n.rank);for(let e=0;e<o.length;e++)o[e]=i[e]%n.shape[e];var s=n.locToIndex(o);a.values[e]=n.values[s]}return a},rt=function(n,e,t,r,a){var i=e[e.length-1],[o,s]=[n.length/i,i],u=D.util.getTypedArrayFromDType(t,o*r),l=D.util.getTypedArrayFromDType("int32",o*r);for(let e=0;e<o;e++){var d=e*s,c=n.subarray(d,d+s),p=[];for(let e=0;e<c.length;e++)p.push({value:c[e],index:e});p.sort((e,n)=>n.value-e.value);var d=e*r,h=u.subarray(d,d+r),f=l.subarray(d,d+r);for(let e=0;e<r;e++)h[e]=p[e].value,f[e]=p[e].index}return(i=e.slice())[i.length-1]=r,[D.buffer(i,t,u),D.buffer(i,"int32",l)]},at=function(n,e,t,r,a){var i=e.length,o=D.util.sizeFromShape(e),s=D.util.computeStrides(e),u=D.util.computeStrides(a),l=D.util.getTypedArrayFromDType(t,D.util.sizeFromShape(a));for(let e=0;e<o;++e){var d=D.util.indexToLoc(e,i,s),c=new Array(d.length);for(let e=0;e<c.length;e++)c[e]=d[r[e]];l[D.util.locToIndex(c,i,u)]=n[e]}return l},it=function(n,e,r,t){var a=D.util.parseAxisParam(e,r)[0];const i=[1,r[0],1];for(let e=0;e<a;e++)i[0]*=r[e];i[1]=r[a];for(let e=a+1;e<r.length;e++)i[2]*=r[e];var o={},s=new Int32Array(r[a]);const u=new D.TensorBuffer(i,t,n);var l,d=[],c=1===i[0]&&1===i[2];for(let t=0;t<r[a];t++){let e;if(c)e=n[t].toString();else{var p=[];for(let n=0;n<i[0];n++)for(let e=0;e<i[2];e++)p.push(u.get(n,t,e));e=p.join(",")}void 0!==o[e]?s[t]=o[e]:(l=Object.keys(o).length,o[e]=l,s[t]=l,d.push(t))}(e=i.slice())[1]=Object.keys(o).length;const h=new D.TensorBuffer(e,t);return d.forEach((t,r)=>{for(let n=0;n<i[0];n++)for(let e=0;e<i[2];e++)h.set(u.get(n,t,e),n,r,e)}),(t=r.slice())[a]=e[1],{outputValues:h.values,outputShape:t,indices:s}};function ot(n,e){return["x","y","z","w","u","v"].slice(0,e).map(function(e){return n+"."+e})}function v(e,n){return 1===n?[e]:ot(e,n)}var st=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var n,t,r,a,i=(this.outputShape=e).length;0===i?this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ":(r=v("rc",i),n=m(i),t=function(e,n,t){if(1===e)return"rc > "+n[0];for(var r="",a=e-2;a<e;a++)r+=t[a]+" >= "+n[a],a<e-1&&(r+="||");return r}(i,e,r),i=function(e,n,t,r){if(1===e)return"";e=r.slice(-2);return"\n    int r = "+e[0]+";\n    int c = "+e[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+n+";\n    bool rEdge = rp1 >= "+t+";\n  "}(i,e[e.length-1],e[e.length-2],r),r=r,a=(e=e).length,r=function(e,n){for(var t=[],r=0;r<=1;r++)for(var a=0;a<=1;a++){for(var i=(0===r?"r":"rp1")+", "+(0===a?"c":"cp1"),o=2;o<e;o++)i=n[n.length-1-o]+","+i;t.push(i)}return t}(a,r),a=1!==a?"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")":"getA(rc),\n            rc + 1 >= "+e[0]+" ? 0. : getA(rc + 1),\n            0, 0",this.userCode="\n        void main() {\n          "+n+" rc = getOutputCoords();\n\n          if("+t+") {\n            setOutput(vec4(0));\n          } else {\n            "+i+"\n\n            setOutput(vec4("+a+"));\n          }\n        }\n      ")};var ut=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;for(var t="",r=0;r<4;r++){var a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),1<r&&(a+="thisRC.y += 1;"),t+="\n        "+a+"\n        "+(0<r?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(0<r?"}":"")+"\n      "}this.userCode="\n      "+"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+g(["r","c","d"],n)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+Se(e)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+e[1]+";\n        int cols = "+e[2]+";\n\n        "+t+"\n\n        setOutput(result);\n      }\n    "};b.prototype.acquireTexture=function(e,n,t){var r,a,n=ct(n,t),i=pt(e,n,t),t=(i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]),dt(e,n,this.gpgpu.gl,this.gpgpu.textureConfig,t));return 0<this.freeTextures[i].length?(this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=t,this.log(),r=this.freeTextures[i].shift(),this.usedTextures[i].push(r),r):(n===o.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):n===o.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):n===o.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):n===o.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):n===o.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=t,this.log(),a)},b.prototype.releaseTexture=function(e,n,t,r){if(null!=this.freeTextures){var t=ct(t,r),a=pt(n,t,r),n=(a in this.freeTextures||(this.freeTextures[a]=[]),dt(n,t,this.gpgpu.gl,this.gpgpu.textureConfig,r)),t=D.env().get("WEBGL_DELETE_TEXTURE_THRESHOLD"),r=(-1!==t&&this._numBytesAllocated>t?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=n):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=n),this.numUsedTextures--,this.usedTextures[a]),t=r.indexOf(e);if(t<0)throw new Error("Cannot release a texture that was never provided by this texture manager");r.splice(t,1),this.log()}},b.prototype.log=function(){var e;this.logEnabled&&(e=this.numFreeTextures+this.numUsedTextures,console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+e+")"),e=this._numBytesFree/this._numBytesAllocated,console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*e)+"%)"))},Object.defineProperty(b.prototype,"numBytesAllocated",{get:function(){return this._numBytesAllocated},enumerable:!0,configurable:!0}),Object.defineProperty(b.prototype,"numBytesFree",{get:function(){return this._numBytesFree},enumerable:!0,configurable:!0}),b.prototype.getNumUsedTextures=function(){return this.numUsedTextures},b.prototype.getNumFreeTextures=function(){return this.numFreeTextures},b.prototype.dispose=function(){var n=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e){n.gpgpu.deleteMatrixTexture(e)});for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e){n.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}};var lt=b;function b(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}function dt(e,n,t,r,a){n=function(e,n){switch(e){case o.PACKED_2X2_FLOAT32:return Ke(n);case o.PACKED_2X2_FLOAT16:return Ye(n);case o.UNPACKED_FLOAT32:return Ge(n);case o.UNPACKED_FLOAT16:return ze(n);case o.PACKED_4X1_UNSIGNED_BYTE:return He(n);default:throw new Error("Unknown physical texture type "+e)}}(n,r),r=a?(r=x(e[0],e[1]))[0]*r[1]:(a=U(e[0],e[1]))[0]*a[1],e=function(e,n){if(n===e.R32F)return 4;if(n===e.R16F)return 2;if(n===e.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===e.RGBA16F)return 8;throw new Error("Unknown internal format "+n)}(t,n);return r*e}function ct(e,n){if(e===f.UPLOAD)return o.PACKED_2X2_FLOAT32;if(e===f.RENDER||null==e)return n=n,D.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?o.PACKED_2X2_FLOAT32:o.UNPACKED_FLOAT32:n?o.PACKED_2X2_FLOAT16:o.UNPACKED_FLOAT16;if(e===f.DOWNLOAD||e===f.PIXELS)return o.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+e)}function pt(e,n,t){return e[0]+"_"+e[1]+"_"+n+"_"+t}var C=function(e,n){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      float unaryOperation(float x) {\n        "+n+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},ht="if (isnan(x)) return x;",ft="return x;",xt="return abs(x);",gt="return (x >= 0.0) ? x : (exp(x) - 1.0);",mt=ht+"\n  return (x < 0.0) ? 0.0 : x;\n",vt=ht+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",bt="return x;",Ct="return 1.0 / (1.0 + exp(-1.0 * x));",yt="return x;",kt="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",It="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",wt="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Rt="return 1.0 / (1.0 + exp(-1.0 * x));",Tt=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+n+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "},Nt=function(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1;var n=v("rc",e=(this.outputShape=e).length),t=m(e),r=function(e,n){if(1===e)return"rc";for(var t="",r=0;r<e;r++)t+=n[r],r<e-1&&(t+=",");return t}(e,n),n=n.slice(-2),e=e<=1?"rc":"vec2("+n.join(",")+")";this.userCode="\n      void main() {\n        "+t+" rc = getOutputCoords();\n        vec4 packedInput = getA("+r+");\n\n        setOutput(getChannel(packedInput, "+e+"));\n      }\n    "},Et=D.kernel_impls.whereImpl,St={};var At=D.env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Ft=600;_t=D.KernelBackend,E(Ot=y,Bt=_t),Ot.prototype=null===Bt?Object.create(Bt):(Lt.prototype=Bt.prototype,new Lt),y.prototype.nextDataId=function(){return y.nextDataId++},y.prototype.numDataIds=function(){return this.texData.numDataIds()-this.pendingDeletes},y.prototype.write=function(e,n,t){if((D.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||D.env().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===t&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:t,values:e,usage:f.UPLOAD,refCount:1}),r},y.prototype.refCount=function(e){return this.texData.has(e)?this.texData.get(e).refCount:0},y.prototype.incRef=function(e){this.texData.get(e).refCount++},y.prototype.decRef=function(e){this.texData.has(e)&&this.texData.get(e).refCount--},y.prototype.move=function(e,n,t,r,a){if(D.env().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:t,dtype:r,values:n,usage:f.UPLOAD,refCount:a})},y.prototype.disposeIntermediateTensorInfo=function(e){this.disposeData(e.dataId)},y.prototype.readSync=function(e){var n,t=this.texData.get(e),r=t.values,a=t.dtype,i=t.complexTensorInfos,o=t.slice,s=t.shape,t=t.isPacked;return null!=o?(o=void 0,o=new(t?Tt:C)(s,bt),t=this.runWebGLProgram(o,[{dataId:e,shape:s,dtype:a}],a),o=this.readSync(t.dataId),this.disposeIntermediateTensorInfo(t),o):null!=r?this.convertAndCacheOnCPU(e):"string"===a?r:((s=null!=this.activeTimers)&&(n=D.util.now()),r="complex64"===a?(t=this.readSync(i.real.dataId),o=this.readSync(i.imag.dataId),D.backend_util.mergeRealAndImagArrays(t,o)):this.getValuesFromTexture(e),s&&(this.downloadWaitMs+=D.util.now()-n),this.convertAndCacheOnCPU(e,r))},y.prototype.read=function(h){return S(this,void 0,void 0,function(){var n,t,r,a,i,o,s,u,l,d,c,p;return A(this,function(e){switch(e.label){case 0:if(this.pendingRead.has(h))return n=this.pendingRead.get(h),[2,new Promise(function(e){return n.push(e)})];if(l=this.texData.get(h),u=l.values,t=l.shape,p=l.slice,r=l.dtype,a=l.complexTensorInfos,l=l.isPacked,null!=p)return p=void 0,p=new(l?Tt:C)(t,bt),l=this.runWebGLProgram(p,[{dataId:h,shape:t,dtype:r}],r),p=this.read(l.dataId),this.disposeIntermediateTensorInfo(l),[2,p];if(null!=u)return[2,this.convertAndCacheOnCPU(h)];if(D.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")||2!==D.env().getNumber("WEBGL_VERSION"))return i=null,"complex64"!==r&&D.env().get("WEBGL_BUFFER_SUPPORTED")&&(o=this.decode(h),l=this.texData.get(o.dataId),i=(p=this.gpgpu).createBufferFromTexture.apply(p,[l.texture].concat(z(t)))),this.pendingRead.set(h,[]),"complex64"===r?[3,2]:[4,this.gpgpu.createAndWaitForFence()];throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");case 1:e.sent(),e.label=2;case 2:return"complex64"!==r?[3,4]:[4,Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)])];case 3:return u=e.sent(),p=u[0],l=u[1],s=D.backend_util.mergeRealAndImagArrays(p,l),[3,5];case 4:s=null==i?this.getValuesFromTexture(h):(c=D.util.sizeFromShape(t),this.gpgpu.downloadFloat32MatrixFromBuffer(i,c)),e.label=5;case 5:return null!=o&&this.disposeIntermediateTensorInfo(o),d=this.convertAndCacheOnCPU(h,s),c=this.pendingRead.get(h),this.pendingRead.delete(h),c.forEach(function(e){return e(d)}),this.pendingDisposal.has(h)&&(this.pendingDisposal.delete(h),this.disposeData(h)&&D.engine().removeDataId(h,this),this.pendingDeletes--),[2,d]}})})},y.prototype.bufferSync=function(e){var n=this.readSync(e.dataId),t=n;if("string"===e.dtype)try{t=n.map(function(e){return D.util.decodeString(e)})}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return D.buffer(e.shape,e.dtype,t)},y.prototype.checkNumericalProblems=function(e){if(null!=e)for(var n=0;n<e.length;n++){var t=e[n];if(!H(t)){if(D.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value "+t+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value "+t+" cannot be represented on this device.")}}},y.prototype.getValuesFromTexture=function(e){var n,t,r,a=this.texData.get(e),i=a.shape,o=a.dtype,a=a.isPacked,s=D.util.sizeFromShape(i);return D.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")?(n=this.decode(e),r=this.texData.get(n.dataId),t=(t=this.gpgpu).downloadMatrixFromPackedTexture.apply(t,[r.texture].concat(z(i))).subarray(0,s),this.disposeIntermediateTensorInfo(n),t):(n=(r=D.env().getBool("WEBGL_PACK")&&!0===a)?me(i):i,t=new(r?De:Oe)(n),a=this.runWebGLProgram(t,[{shape:n,dtype:o,dataId:e}],"float32"),i=this.texData.get(a.dataId),r=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(i.texture,i.texShape[0],i.texShape[1]).subarray(0,s),this.disposeIntermediateTensorInfo(a),r)},y.prototype.timerAvailable=function(){return 0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")},y.prototype.time=function(o){return S(this,void 0,void 0,function(){var n,t,r,a,i;return A(this,function(e){switch(e.label){case 0:return(a=this.activeTimers,n=!(t=[]),null==this.programTimersStack?(this.programTimersStack=t,n=!0):this.activeTimers.push(t),this.activeTimers=t,o(),t=D.util.flatten(this.activeTimers.map(function(e){return e.query})).filter(function(e){return null!=e}),r=D.util.flatten(this.activeTimers.map(function(e){return e.name})).filter(function(e){return null!=e}),this.activeTimers=a,n&&(this.programTimersStack=null),a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE"))?[4,Promise.all(t)]:[3,2];case 1:return i=e.sent(),a.kernelMs=D.util.sum(i),a.getExtraProfileInfo=function(){return i.map(function(e,n){return{name:r[n],ms:e}}).map(function(e){return e.name+": "+e.ms}).join(", ")},[3,3];case 2:a.kernelMs={error:"WebGL query timers are not supported in this environment."},e.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,a]}})})},y.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}},y.prototype.startTimer=function(){return 0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")?this.gpgpu.beginQuery():{startMs:D.util.now(),endMs:null}},y.prototype.endTimer=function(e){return 0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")?this.gpgpu.endQuery():e.endMs=D.util.now(),e},y.prototype.getQueryTime=function(n){return S(this,void 0,void 0,function(){return A(this,function(e){return 0<D.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")?[2,this.gpgpu.waitForQueryAndGetTime(n)]:[2,n.endMs-n.startMs]})})},y.prototype.disposeData=function(e,n){if(void 0===n&&(n=!1),this.pendingDisposal.has(e))return!1;if(this.texData.has(e)){if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&0<this.texData.get(e).refCount)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);var t=this.texData.get(e).complexTensorInfos;null!=t&&(this.disposeData(t.real.dataId,n),this.disposeData(t.imag.dataId,n)),this.texData.delete(e)}return!0},y.prototype.releaseGPUData=function(e){var n=this.texData.get(e),t=n.texture,r=n.dtype,a=n.texShape,i=n.usage,o=n.isPacked,n=n.slice,n=n&&n.origDataId||e,s=this.dataRefCount.get(n),s=(1<s?this.dataRefCount.set(n,s-1):(this.dataRefCount.delete(n),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(t,a,i,o))),this.texData.get(e));s.texture=null,s.texShape=null,s.isPacked=!1,s.slice=null},y.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture},y.prototype.getDataInfo=function(e){return this.texData.get(e)},y.prototype.shouldExecuteOnCPU=function(e,n){var t=this;return void 0===n&&(n=At),D.env().getBool("WEBGL_CPU_FORWARD")&&e.every(function(e){return null==t.texData.get(e.dataId).texture&&D.util.sizeFromShape(e.shape)<n})},y.prototype.getGPGPUContext=function(){return this.gpgpu},y.prototype.where=function(e){D.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var n=e.dataSync();return Et(e.shape,n)},y.prototype.packedUnaryOp=function(e,n,t){n=new Tt(e.shape,n),n=this.compileAndRun(n,[e],t);return D.engine().makeTensorFromDataId(n.dataId,n.shape,n.dtype)},y.prototype.abs=function(e){var n;return this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype?(n=Kn(this.texData.get(e.dataId).values),this.makeOutput(e.shape,e.dtype,n)):D.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?this.packedUnaryOp(e,xt,e.dtype):(n=new C(e.shape,xt),n=this.compileAndRun(n,[e]),D.engine().makeTensorFromDataId(n.dataId,n.shape,n.dtype))},y.prototype.makeTensorInfo=function(e,n,t){var r;return r="string"===n&&null!=t&&0<t.length&&D.util.isString(t[0])?(r=t.map(function(e){return D.util.encodeString(e)}),this.write(r,e,n)):this.write(t,e,n),this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}},y.prototype.makeOutput=function(e,n,t){t=this.makeTensorInfo(e,n,t).dataId;return D.engine().makeTensorFromDataId(t,e,n,this)},y.prototype.unpackTensor=function(e){var n=new Nt(e.shape);return this.runWebGLProgram(n,[e],e.dtype)},y.prototype.packTensor=function(e){var n=new st(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)},y.prototype.packedReshape=function(e,n){var t=[d(e.shape)].concat(h(e.shape)),r={dtype:e.dtype,shape:t,dataId:e.dataId},a=[d(n)].concat(h(n)),a=new ut(a,t),t=this.runWebGLProgram(a,[r],e.dtype,null,!0);return{dataId:t.dataId,shape:n,dtype:t.dtype}},y.prototype.decode=function(e){var n=this.texData.get(e),t=n.isPacked,r=n.shape,n=n.dtype,a=me(r),t=new(t?_e:Fe)(a);return{dtype:n,shape:r,dataId:this.runWebGLProgram(t,[{shape:a,dtype:n,dataId:e}],n,null,!0).dataId}},y.prototype.runWebGLProgram=function(c,e,n,t,r){var a,p,h,i,o,s,u,l,d,f,x,g,m=this,n=(void 0===r&&(r=!1),this.makeTensorInfo(c.outputShape,n)),v=this.texData.get(n.dataId);return c.packedOutput&&(v.isPacked=!0),c.outPackingScheme===F.DENSE&&(i=z(c.outputShape),v.texShape=i.map(function(e){return 2*e})),null!=c.outTexUsage&&(v.usage=c.outTexUsage),0===D.util.sizeFromShape(n.shape)?(v.values=D.util.getTypedArrayFromDType(n.dtype,0),n):(a=[],p=e.map(function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n,t,r=m.texData.get(e.dataId);if(null==r.texture){if(!c.packedInputs&&D.util.sizeFromShape(e.shape)<=D.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:r.values};c.packedInputs&&(r.isPacked=!0,r.shape=e.shape)}else!!r.isPacked!=!!c.packedInputs?(e=r.isPacked?m.unpackTensor(e):m.packTensor(e),a.push(e),r=m.texData.get(e.dataId)):r.isPacked&&!Ce(r.shape,e.shape)&&(t=(n=e).shape,e.shape=r.shape,e=m.packedReshape(e,t),a.push(e),r=m.texData.get(e.dataId),n.shape=t);return m.uploadToGPU(e.dataId),{shape:e.shape,texData:r,isUniform:!1}}),this.uploadToGPU(n.dataId),h={shape:n.shape,texData:v,isUniform:!1},i=c,e=h,o="",(s=p).concat(e).forEach(function(e){var n=null!=e.texData&&null!=e.texData.slice&&0<e.texData.slice.flatOffset,t=e.isUniform?"uniform":e.texData.texShape;o+=e.shape+"_"+t+"_"+n}),s=i.userCode,e=i.constructor.name,s=e+="_"+o+"_"+s,e=this.getAndSaveBinary(s,function(){for(var e=m.gpgpu,r=c,n=p,t=h,a=r.userCode,i=(n=n.map(function(e,n){var t={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&0<e.texData.slice.flatOffset&&(t.flatOffset=e.texData.slice.flatOffset),{name:r.variableNames[n],shapeInfo:t}})).map(function(e){return e.shapeInfo}),t={logicalShape:t.shape,texShape:t.texData.texShape,isUniform:!1,isPacked:t.texData.isPacked,flatOffset:null},n=ln(n,t,a,r.packedInputs),o=e.createProgram(n),a=null,s=e.getUniformLocation(o,"NAN",!1),u=(1===D.env().getNumber("WEBGL_VERSION")&&(a=e.getUniformLocation(o,"INFINITY",!1)),{}),l=0;l<r.variableNames.length;l++){var d=r.variableNames[l];u[d]=e.getUniformLocation(o,d,!1),u["offset"+d]=e.getUniformLocation(o,"offset"+d,!1)}return{program:r,source:n,webGLProgram:o,uniformLocations:u,inShapeInfos:i,outShapeInfo:t,infLoc:a,nanLoc:s}}),(s=null!=this.activeTimers)&&(u=this.startTimer()),l=this.gpgpu,f=p,x=h,t=t,gn((d=e).inShapeInfos,f),gn([d.outShapeInfo],[x]),e=x.texData.texture,g=x.texData.texShape,x.texData.isPacked?l.setOutputPackedMatrixTexture(e,g[0],g[1]):l.setOutputMatrixTexture(e,g[0],g[1]),l.setProgram(d.webGLProgram),1===D.env().getNumber("WEBGL_VERSION")&&null!==d.infLoc&&l.gl.uniform1f(d.infLoc,1/0),null!==d.nanLoc&&l.gl.uniform1f(d.nanLoc,NaN),f.forEach(function(e,n){var t,r=d.program.variableNames[n],a=d.uniformLocations[r],r=d.uniformLocations["offset"+r];null!=a&&(e.isUniform?D.util.sizeFromShape(e.shape)<2?l.gl.uniform1f(a,e.uniformValues[0]):((t=e.uniformValues)instanceof Float32Array||(t=new Float32Array(t)),l.gl.uniform1fv(a,t)):(null!=e.texData.slice&&null!=r&&l.gl.uniform1i(r,e.texData.slice.flatOffset),l.setInputMatrixTexture(e.texData.texture,a,n)))}),null!=t&&t(l,d.webGLProgram),l.executeProgram(),a.forEach(function(e){return m.disposeIntermediateTensorInfo(e)}),s&&(u=this.endTimer(u),this.activeTimers.push({name:c.constructor.name,query:this.getQueryTime(u)})),0<(x=D.env().get("WEBGL_FLUSH_THRESHOLD"))&&(e=D.util.now())-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e),!D.env().getBool("WEBGL_LAZILY_UNPACK")&&v.isPacked&&!1===r?(g=this.unpackTensor(n),this.disposeIntermediateTensorInfo(n),g):n)},y.prototype.compileAndRun=function(e,n,t,r,a){return t=t||n[0].dtype,this.runWebGLProgram(e,n,t,r,a=void 0===a?!1:a)},y.prototype.getAndSaveBinary=function(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]},y.prototype.getTextureManager=function(){return this.textureManager},y.prototype.dispose=function(){var n=this;this.disposed||(D.env().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(function(e){n.gpgpu.deleteProgram(n.binaryCache[e].webGLProgram),delete n.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},y.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=D.tidy(function(){if(!D.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){var e=D.env().getBool("DEBUG"),n=(D.env().set("DEBUG",!1),t.abs(D.scalar(1e-8)).dataSync()[0]);if(D.env().set("DEBUG",e),0<n)return 32}return 16})),this.floatPrecisionValue},y.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},y.prototype.uploadToGPU=function(e){var n,t,r,a,i,o,s,e=this.texData.get(e),u=e.shape,l=e.dtype,d=e.values,c=e.texture,p=e.usage,h=e.isPacked;null==c&&((c=null!=this.activeTimers)&&(n=D.util.now()),null==(t=e.texShape)&&(t=ve(u,h),e.texShape=t),null!=d?(u=me(u),a=void 0,s=t[1],r=t[0],o=d instanceof Uint8Array,a=new(h?(s=(i=x(t[0],t[1]))[0],r=i[1],Pe):Le)(u,[r,s],o),i=this.makeTensorInfo([r,s],l),this.texData.get(i.dataId).usage=o?f.PIXELS:f.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(i.dataId),s,r,d),u=this.runWebGLProgram(a,[i],l,null,!0),o=this.texData.get(u.dataId),e.texture=o.texture,e.texShape=o.texShape,e.isPacked=o.isPacked,e.usage=o.usage,this.disposeIntermediateTensorInfo(i),this.texData.delete(u.dataId),e.values=null,c&&(this.uploadWaitMs+=D.util.now()-n)):(s=this.acquireTexture(t,p,l,h),e.texture=s))},y.prototype.convertAndCacheOnCPU=function(e,n){var t=this.texData.get(e),r=t.dtype;return this.releaseGPUData(e),null!=n&&(t.values=function(e,n){{if("float32"===n||"complex64"===n)return e;if("int32"!==n&&"bool"!==n)throw new Error("Unknown dtype "+n);for(var t=new("int32"===n?Int32Array:Uint8Array)(e.length),r=0;r<t.length;++r)t[r]=Math.round(e[r]);return t}}(n,r)),t.values},y.prototype.acquireTexture=function(e,n,t,r){return this.numBytesInGPU+=this.computeBytes(e,t),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024&&(t=(this.numBytesInGPU/1024/1024).toFixed(2),this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+t+" MB, most likely due to a memory leak")),this.textureManager.acquireTexture(e,n,r)},y.prototype.computeBytes=function(e,n){return e[0]*e[1]*D.util.bytesPerElement(n)},y.nextDataId=0;var _t,Ot,Dt=y;function Lt(){this.constructor=Ot}function y(e){var n,t,r=_t.call(this)||this;if(r.pendingRead=new WeakMap,r.pendingDisposal=new WeakSet,r.dataRefCount=new WeakMap,r.numBytesInGPU=0,r.uploadWaitMs=0,r.downloadWaitMs=0,r.lastGlFlushTime=0,r.warnedAboutMemory=!1,r.pendingDeletes=0,r.disposed=!1,D.env().getBool("HAS_WEBGL"))return null==e?(n=i(D.env().getNumber("WEBGL_VERSION")),r.binaryCache=((t=D.env().getNumber("WEBGL_VERSION"))in St||(St[t]={}),St[t]),r.gpgpu=new sn(n),r.canvas=n.canvas,r.gpgpuCreatedLocally=!0):(r.gpgpu=e,r.binaryCache={},r.gpgpuCreatedLocally=!1,r.canvas=e.gl.canvas),r.textureManager=new lt(r.gpgpu),r.numMBBeforeWarning=null==D.env().global.screen?1024:D.env().global.screen.height*D.env().global.screen.width*window.devicePixelRatio*Ft/1024/1024,r.texData=new D.DataStorage(r,D.engine()),r;throw new Error("WebGL is not supported on this device")}function Pt(){D.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}D.device_util.isBrowser()&&D.registerBackend("webgl",function(){return new Dt},2);var Bt={forceHalfFloat:Pt},Vt=function(e,n,t){this.variableNames=["A","B"],this.outputShape=D.backend_util.assertAndGetBroadcastShape(n,t),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+e+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "},Wt=function(e,n,t,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=D.backend_util.assertAndGetBroadcastShape(n,t),n=this.outputShape.length,t="",r&&(0===n||1===D.util.sizeFromShape(this.outputShape)?t="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ":(t="\n          "+m(n)+" coords = getOutputCoords();\n        ",t+=1===n?"\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":"\n            bool nextRowOutOfBounds =\n              ("+(r=v("coords",n))[n-2]+" + 1) >= "+this.outputShape[n-2]+";\n            bool nextColOutOfBounds =\n              ("+r[n-1]+" + 1) >= "+this.outputShape[n-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")),this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+t+"\n\n        setOutput(result);\n      }\n    "};function I(e){var n=e.inputs,e=e.backend,n=n.x;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Mt={kernelName:D.Identity,backendName:"webgl",kernelFunc:I};function w(e){var n=e.inputs,e=e.backend,t=n.real,n=n.imag,r=e.makeTensorInfo(t.shape,"complex64"),a=e.texData.get(r.dataId),t=I({inputs:{x:t},backend:e}),n=I({inputs:{x:n},backend:e});return a.complexTensorInfos={real:t,imag:n},r}var Gt={kernelName:D.Complex,backendName:"webgl",kernelFunc:w},Ut="return (a < 0.) ? b * a : a;",zt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Xt={kernelName:D.LeakyRelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,e=e.alpha,e=t.makeTensorInfo([],"float32",D.util.createScalarValue(e,"float32")),r=D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wt(zt,n.shape,e.shape):new Vt(Ut,n.shape,e.shape),r=t.runWebGLProgram(r,[n,e],n.dtype);return t.disposeIntermediateTensorInfo(e),r}},Ht="return (a < 0.) ? b * a : a;",jt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Kt={kernelName:D.Prelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.x,n=n.alpha,r=D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wt(jt,t.shape,n.shape):new Vt(Ht,t.shape,n.shape);return e.runWebGLProgram(r,[t,n],t.dtype)}};function R(e){var a=e.opSnippet,i=e.packedOpSnippet,o=e.cpuKernelImpl,s=e.dtype;return function(e){var n,t=e.inputs,e=e.backend,t=t.x,r=s||t.dtype;return e.shouldExecuteOnCPU([t])&&null!=o?(n=e.texData.get(t.dataId),n=o(n.values,r),e.makeTensorInfo(t.shape,r,n)):(n=D.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=i?new Tt(t.shape,i):new C(t.shape,a),e.runWebGLProgram(n,[t],r))}}function T(e){var u=e.opSnippet,r=e.packedOpSnippet,n=e.checkOutOfBounds,a=void 0!==n&&n,n=e.supportsComplex,l=void 0!==n&&n,d=e.cpuKernelImpl,c=e.dtype;return function(e){var n,t=e.inputs,e=e.backend,i=t.a,o=t.b,s=e;return l&&"complex64"===i.dtype?(t=s.texData.get(i.dataId),e=s.texData.get(o.dataId),n=w({inputs:{real:e=(t=[[t.complexTensorInfos.real,e.complexTensorInfos.real],[t.complexTensorInfos.imag,e.complexTensorInfos.imag]].map(function(e){var n=e[0],e=e[1],t={dataId:n.dataId,dtype:n.dtype,shape:i.shape},r={dataId:e.dataId,dtype:e.dtype,shape:o.shape},a=new Vt(u,i.shape,o.shape);return s.runWebGLProgram(a,[t,r],D.upcastType(n.dtype,e.dtype))}))[0],imag:t=t[1]},backend:s}),s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(t),n):(e=c||D.upcastType(i.dtype,o.dtype),"string"!==i.dtype&&"string"!==o.dtype&&!s.shouldExecuteOnCPU([i,o])||null==d?(t=D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=r?new Wt(r,i.shape,o.shape,a):new Vt(u,i.shape,o.shape),s.runWebGLProgram(t,[i,o],e)):(n=s.texData.get(i.dataId).values,t=s.texData.get(o.dataId).values,n="string"===i.dtype?D.backend_util.fromUint8ToStringArray(n):n,t="string"===i.dtype?D.backend_util.fromUint8ToStringArray(t):t,t=(n=d(i.shape,o.shape,n,t,e))[0],n=n[1],n=s.makeTensorInfo(n,e),s.texData.get(n.dataId).values=t,n))}}function qt(e,n){if(void 0===n&&(n=!1),"linear"===e)return n?yt:ft;if("relu"===e)return n?It:mt;if("elu"===e)return n?kt:gt;if("relu6"===e)return n?wt:vt;if("prelu"===e)return n?jt:Ht;if("leakyrelu"===e)return n?zt:Ut;if("sigmoid"===e)return n?Rt:Ct;throw new Error("Activation "+e+" has not been implemented for the WebGL backend.")}var Yt=function(e,n,t,r,a,i,o,s,u){void 0===r&&(r=!1),void 0===a&&(a=!1),void 0===i&&(i=!1),void 0===o&&(o=null),void 0===s&&(s=!1),void 0===u&&(u=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;var t=r?e[1]:e[2],t=Math.ceil(t/2),l=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",r=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],a=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],c="",p="",o=(o&&(c=s?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+o+"\n        }":u?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          "+o+"\n        }":"vec4 activation(vec4 x) {\n          "+o+"\n        }",p="result = activation(result);"),i?"result += getBiasAtOutCoords();":""),i=(i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha"),"rc.x"),s="rc.x";e[0]<n[0]?i="int(min(float(rc.x), "+(e[0]-1)+".))":n[0]<e[0]&&(s="int(min(float(rc.x), "+(n[0]-1)+".))"),this.userCode="\n      "+c+"\n\n      const float sharedDimension = "+t+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+t+"; i++) {\n          int batchA = "+i+";\n          int batchB = "+s+";\n          vec4 a = getMatrixA(batchA, "+l+");\n          vec4 b = getMatrixB(batchB, "+d+");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += ("+r[0]+" * "+a[0]+");\n          result += ("+r[1]+" * "+a[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+o+"\n\n        "+p+"\n\n        setOutput(result);\n      }\n    "},Qt={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Zt=function(e,n,t){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=D.backend_util.assertAndGetBroadcastShape(n,t),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+e+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "},$t="return a * b;";function Jt(e){var n,t,r,a,i,o=e.inputs,e=e.backend,s=o.a,o=o.b,u=D.backend_util.upcastType(s.dtype,o.dtype);return"complex64"===s.dtype?(a=e.texData.get(s.dataId),i=e.texData.get(o.dataId),n=new Zt(Qt.REAL,s.shape,o.shape),t=new Zt(Qt.IMAG,s.shape,o.shape),r=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:o.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:o.shape}],r=w({inputs:{real:n=e.runWebGLProgram(n,r,"float32"),imag:t=e.runWebGLProgram(t,r,"float32")},backend:e}),e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(t),r):e.shouldExecuteOnCPU([s,o])?(a=e.texData.get(s.dataId),i=e.texData.get(o.dataId),t=(n=zn(s.shape,o.shape,a.values,i.values,u))[0],r=n[1],a=e.makeTensorInfo(r,u),e.texData.get(a.dataId).values=t,a):(i=new(D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?Wt:Vt)($t,s.shape,o.shape),e.runWebGLProgram(i,[s,o],u))}var er={kernelName:D.Multiply,backendName:"webgl",kernelFunc:Jt};function O(e){var n,t,r,a=e.inputs,i=e.backend,e=e.attrs,o=a.x,a=e.shape,e=i,s=D.util.sizeFromShape(o.shape),u=D.util.inferFromImplicitShape(a,s),l=D.util.sizeFromShape(u),i=(D.util.assert(s===l,function(){return"The new shape ("+u+") has "+l+" elements and the old shape ("+o.shape+") has "+s+" elements. The new shape and old shape must have the same number of elements."}),e.texData.get(o.dataId));return!i.isPacked||Ce(o.shape,u)||null!==i.texture&&Ce(i.shape,u)?(e.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype}):(a=u,i=e,n=[d((e=o).shape)].concat(h(e.shape)),t={dtype:e.dtype,shape:n,dataId:e.dataId},r=[d(a)].concat(h(a)),r=new ut(r,n),{dataId:(n=i.runWebGLProgram(r,[t],e.dtype,null,!0)).dataId,shape:a,dtype:n.dtype})}var nr={kernelName:D.Reshape,backendName:"webgl",kernelFunc:O},tr=function(e,n){this.variableNames=["x"];var t=e.windowSize,r=e.batchSize,a=e.inSize,e=e.outSize,r=(this.outputShape=[r,e],4*Math.floor(t/4)),e=t%4,i="sumValue += dot(values, ones);",n=(null!=n&&(i="sumValue += dot(values * "+(D.util.isInt(n=1/n)?n.toPrecision(2):n)+", ones);"),"");this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+(n=0<a%t?"\n        if (inIdx < 0 || inIdx >= "+a+") {\n          return 0.0;\n        }\n      ":n)+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+t+";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+r+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+i+"\n        }\n\n        int inIdx = inOffset + "+r+";\n        if ("+(1==e)+") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          "+i+"\n        } else if ("+(2==e)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          "+i+"\n        } else if ("+(3==e)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          "+i+"\n        }\n        setOutput(sumValue);\n      }\n    "},rr=function(e,n){this.variableNames=["x"];var t=e.windowSize,r=e.batchSize,a=e.inSize,e=e.outSize,r=(this.outputShape=[r,e],"0.0"),e="",i=("prod"===n?r="1.0":"min"===n?(r="1.0 / 1e-20",e="min"):"max"===n&&(r="-1.0 / 1e-20",e="max"),n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])"),o=("sum"===n?i="sumValue":"prod"===n?i="prodValue":"all"===n?i="allValue":"any"===n&&(i="anyValue"),4*Math.floor(t/4)),s=t%4,e="\n      if ("+("sum"===n)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===n)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+e+"(values, minMaxValue);\n        if ("+("min"===n)+" || "+("max"===n)+") {\n          minMaxValue = "+e+"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    ",u="vec4",n=("all"===n?(r="1.0",e="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",u="bvec4"):"any"===n&&(r="0.0",e="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",u="bvec4"),"");this.userCode="\n      const float initializationValue = "+r+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+(n=0<a%t?"\n        if (inIdx < 0 || inIdx >= "+a+") {\n          return initializationValue;\n        }\n      ":n)+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+t+";\n\n        vec4 minMaxValue = vec4("+r+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+o+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+u+" values = "+u+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+e+"\n        }\n\n        int inIdx = inOffset + "+o+";\n        if ("+(1==s)+") {\n          "+u+" values = "+u+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+e+"\n        } else if ("+(2==s)+") {\n          "+u+" values = "+u+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+e+"\n        } else if ("+(3==s)+") {\n          "+u+" values = "+u+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+e+"\n        }\n        setOutput("+i+");\n      }\n    "};function N(e,n,t,r){for(var a=function(e){for(var n=[];0===n.length||1!==n[n.length-1].outSize;){var t=n.length?n[n.length-1].outSize:e[1],r=D.backend_util.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return n}(e.shape),i=e,o=0;o<a.length;o++){var s=a[o],u=s.inSize,l=s.windowSize,s=s.outSize,d=void 0,d="mean"===t?0===o?new tr({windowSize:l,inSize:u,batchSize:e.shape[0],outSize:s},u):new tr({windowSize:l,inSize:u,batchSize:e.shape[0],outSize:s}):new rr({windowSize:l,inSize:u,batchSize:e.shape[0],outSize:s},t),l=i,i=r.runWebGLProgram(d,[i],n);l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return i}var ar=function(e,n){this.variableNames=["A"];for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[n[r]];this.outputShape=t,this.rank=t.length;var a=m(this.rank),i=function(e){var n=e.length;if(6<n)throw Error("Transpose for rank "+n+" is not yet supported");for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n),a=0;a<e.length;a++)r[e[a]]=t[a];return r.join()}(n);this.userCode="\n    void main() {\n      "+a+" resRC = getOutputCoords();\n      setOutput(getA("+i+"));\n    }\n    "};var ir=function(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[n[r]];if(this.outputShape=t,this.rank=t.length,6<this.rank)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");for(var a=m(this.rank),i=ot("rc",this.rank),o=new Array(this.rank),r=0;r<n.length;r++)o[n[r]]=i[r];var s="vec2("+o.slice(-2).join()+")",u="++"+i[this.rank-1]+" < "+t[this.rank-1],s="getChannel(getA("+o.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+a+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+s+";\n      if("+u+") {\n        result[1] = "+s+";\n      }\n      --"+i[this.rank-1]+";\n      if(++"+i[this.rank-2]+" < "+t[this.rank-2]+") {\n        result[2] = "+s+";\n        if("+u+") {\n          result[3] = "+s+";\n        }\n      }\n      setOutput(result);\n    }\n    "};function or(e,n,t){n=new(D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?ir:ar)(e.shape,n);return t.runWebGLProgram(n,[e],e.dtype)}function sr(e){var n,t,r,a,i,o=e.inputs,s=e.backend,e=e.attrs,o=o.x,u=e.axis,e=e.keepDims;return u=u,e=e,s=s,n=(o=o).shape.length,t=u=D.util.parseAxisParam(u,o.shape),r=null!=(i=D.backend_util.getAxesPermutation(t,n)),a=o,r&&(a=or(o,i,s),t=D.backend_util.getInnerMostAxes(t.length,n)),D.backend_util.assertAxesAreInnerMostDims("sum",t,n),n=(i=D.backend_util.computeOutAndReduceShapes(a.shape,t))[0],t=i[1],i=n,e&&(i=D.backend_util.expandShapeToKeepDim(n,u)),e=D.util.sizeFromShape(t),n=O({inputs:{x:a},attrs:{shape:[D.util.sizeFromShape(o.shape)/e,e]},backend:s}),t=O({inputs:{x:u=N(n,D.sumOutType(o.dtype),"sum",s)},attrs:{shape:i},backend:s}),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(u),r&&s.disposeIntermediateTensorInfo(a),t}var ur={kernelName:D.Sum,backendName:"webgl",kernelFunc:sr};function M(e){for(var n,t=e.inputs,r=e.backend,e=e.attrs,a=t.x,i=e.perm,t=r,e=a.shape.length,o=new Array(e),s=0;s<o.length;s++)o[s]=a.shape[i[s]];return t.shouldExecuteOnCPU([a])?(r=t.texData.get(a.dataId).values,e=at(r,a.shape,a.dtype,i,o),n=t.makeTensorInfo(o,a.dtype),t.texData.get(n.dataId).values=e):n=or(a,i,t),n}var lr={kernelName:D.Transpose,backendName:"webgl",kernelFunc:M},dr=1e3;function cr(e){var n=e.a,t=e.b,r=e.transposeA,a=e.transposeB,i=e.backend,o=e.bias,o=void 0===o?null:o,s=e.preluActivationWeights,s=void 0===s?null:s,u=e.leakyreluAlpha,u=void 0===u?0:u,e=e.activation,e=void 0===e?null:e,l=n.shape.length,d=t.shape.length,c=r?n.shape[l-2]:n.shape[l-1],p=a?t.shape[d-1]:t.shape[d-2],h=r?n.shape[l-1]:n.shape[l-2],f=a?t.shape[d-2]:t.shape[d-1],x=n.shape.slice(0,-2),g=t.shape.slice(0,-2),m=D.util.sizeFromShape(x),v=D.util.sizeFromShape(g);D.util.assert(2<=l&&2<=d&&(m===v||1===m||1===v),function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of ("+x+") and ("+g+")."});var b,C,y,k,l=(v<m?n:t).shape.slice(0,-2).concat([h,f]),d=(D.util.assert(c===p,function(){return"Error in matMul: inner shapes ("+c+") and ("+p+") of Tensors with shapes "+n.shape+" and "+t.shape+" and transposeA="+r+" and transposeB="+a+" must match."}),r?[m,c,h]:[m,h,c]),I=a?[v,f,p]:[v,p,f],w=O({inputs:{x:n},backend:i,attrs:{shape:d}}),R=O({inputs:{x:t},backend:i,attrs:{shape:I}}),T=[w,R],m=Math.max(m,v),v=r?w.shape[1]:w.shape[2],N=null!=o,E=null!=s,S="leakyrelu"===e,e=null!=e?qt(e,!0):null,A=((1===h||1===f)&&dr<v&&!1==(N||E||S||null!=e)?(k=w,b=R,r&&(k=M({inputs:{x:w},backend:i,attrs:{perm:[0,2,1]}}),T.push(k)),a&&(b=M({inputs:{x:R},backend:i,attrs:{perm:[0,2,1]}}),T.push(b)),A=1===f,C=k,1!==f&&(C=O({inputs:{x:k},backend:i,attrs:{shape:[m,v,1]}}),T.push(C)),k=1===f?2:1,y=b,A&&(y=O({inputs:{x:b},backend:i,attrs:{shape:[m,1,v]}}),T.push(y)),b=sr({inputs:{x:A=Jt({inputs:{a:C,b:y},backend:i})},backend:i,attrs:{axis:k,keepDims:!0}}),T.push(A)):(v=D.upcastType(n.dtype,t.dtype),C=new Yt(d,I,[m,h,f],r,a,N,e,E,S),y=[w,R],null!=o&&y.push(o),E&&y.push(s),S&&(k=i.makeTensorInfo([],"float32",D.util.createScalarValue(u,"float32")),y.push(k),T.push(k)),b=i.runWebGLProgram(C,y,v)),O({inputs:{x:b},backend:i,attrs:{shape:l}}));T.push(b);for(var F=0,_=T;F<_.length;F++)i.disposeIntermediateTensorInfo(_[F]);return A}var pr={kernelName:D._FusedMatMul,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.a,a=n.b,i=n.bias,n=n.preluActivationWeights,o=e.transposeA,s=e.transposeB,u=e.activation;return cr({a:r,b:a,transposeA:o,transposeB:s,backend:t,bias:i,preluActivationWeights:n,leakyreluAlpha:e.leakyreluAlpha,activation:u})}},hr="return abs(x);";var fr={kernelName:D.Abs,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,e=e.backend,t=t.x;return e.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype?(n=e.texData.get(t.dataId),n=Kn(n.values),e.makeTensorInfo(t.shape,t.dtype,n)):(n=new(D.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?Tt:C)(t.shape,hr),e.runWebGLProgram(n,[t],t.dtype))}},xr=R({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),xr={kernelName:D.Acos,backendName:"webgl",kernelFunc:xr},gr=R({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),gr={kernelName:D.Acosh,backendName:"webgl",kernelFunc:gr},mr="return a + b;",mr=T({opSnippet:mr,packedOpSnippet:mr,supportsComplex:!0,cpuKernelImpl:mn}),mn={kernelName:D.Add,backendName:"webgl",kernelFunc:mr},vr=function(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map(function(e,n){return"T"+n});var t=[],e=(this.variableNames.forEach(function(e){t.push("float v"+e+" = get"+e+"AtOutCoords();")}),this.variableNames.map(function(e){return"v"+e}).join(" + "));this.userCode="\n      void main() {\n        "+t.join("\n        ")+"\n\n        float result = "+e+";\n        setOutput(result);\n      }\n    "},br=function(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map(function(e,n){return"T"+n});var t=[],e=(this.variableNames.forEach(function(e){t.push("vec4 v"+e+" = get"+e+"AtOutCoords();")}),this.variableNames.map(function(e){return"v"+e}).join(" + "));this.userCode="\n      void main() {\n        "+t.join("\n        ")+"\n\n        vec4 result = "+e+";\n        setOutput(result);\n      }\n    "};mr={kernelName:D.AddN,backendName:"webgl",kernelFunc:function e(n){var t,r,a=n.inputs,n=n.backend;return 1===a.length?I({inputs:{x:a[0]},backend:n}):a.length>D.env().get("WEBGL_MAX_TEXTURES_IN_SHADER")?(r=Math.floor(a.length/2),t=e({inputs:a.slice(0,r),backend:n}),r=e({inputs:a.slice(r),backend:n}),e({inputs:[t,r],backend:n})):(t=a.map(function(e){return e.dtype}).reduce(function(e,n){return D.upcastType(e,n)}),r=a.map(function(e){return e.shape}),r=new(D.env().getBool("WEBGL_PACK")?br:vr)(a[0].shape,r),n.runWebGLProgram(r,a,t))}};var Cr={kernelName:D.All,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.axis,e=e.keepDims,a=n.shape.length,i=r=D.util.parseAxisParam(r,n.shape),o=D.backend_util.getAxesPermutation(i,a),s=n;null!=o&&(s=M({inputs:{x:n},backend:t,attrs:{perm:o}}),i=D.backend_util.getInnerMostAxes(i.length,a)),D.backend_util.assertAxesAreInnerMostDims("all",i,a);a=(n=D.backend_util.computeOutAndReduceShapes(s.shape,i))[0],i=n[1],i=N(n=O({inputs:{x:s},backend:t,attrs:{shape:[-1,D.util.sizeFromShape(i)]}}),n.dtype,"all",t);return e=O(e?{inputs:{x:i},backend:t,attrs:{shape:D.backend_util.expandShapeToKeepDim(a,r)}}:{inputs:{x:i},backend:t,attrs:{shape:a}}),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),null!=o&&t.disposeIntermediateTensorInfo(s),e}};var yr={kernelName:D.Any,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.axis,e=e.keepDims,a=n.shape.length,i=r=D.util.parseAxisParam(r,n.shape),o=D.backend_util.getAxesPermutation(i,a),s=n;null!=o&&(s=M({inputs:{x:n},backend:t,attrs:{perm:o}}),i=D.backend_util.getInnerMostAxes(i.length,a)),D.backend_util.assertAxesAreInnerMostDims("any",i,a);a=(n=D.backend_util.computeOutAndReduceShapes(s.shape,i))[0],i=n[1],i=N(n=O({inputs:{x:s},backend:t,attrs:{shape:[-1,D.util.sizeFromShape(i)]}}),n.dtype,"any",t);return e=O(e?{inputs:{x:i},backend:t,attrs:{shape:D.backend_util.expandShapeToKeepDim(a,r)}}:{inputs:{x:i},backend:t,attrs:{shape:a}}),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),null!=o&&t.disposeIntermediateTensorInfo(s),e}},kr=function(e,n,t){this.variableNames=["A"];var r=e.windowSize,a=e.batchSize,e=e.outSize,a=(t||this.variableNames.push("bestIndicesA"),this.outputShape=[a,e],"max"===n?">":"<");this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+(t?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));")+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+a+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "},Ir=function(e,n,t,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,D.util.assert(2<e.length,function(){return"Packed arg"+(t.charAt(0).toUpperCase()+t.slice(1))+" supports only inputs with rank above 2."});var a=e[e.length-1],a=Math.ceil(a/n);this.outputShape=e.slice(0,-1),1<a&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i=(e=this.outputShape).length,o=m(i),s=v("coords",i),u=(a=1===a?"\n        "+(a=m(f=i+1))+" sourceLocR = "+a+"("+s.join()+", 0);\n        ++"+s[i-1]+";\n        "+a+" sourceLocG = "+a+"("+s.join()+", 0);\n        ++"+s[i-2]+";\n        "+a+" sourceLocA = "+a+"("+s.join()+", 0);\n        --"+s[i-1]+";\n        "+a+" sourceLocB = "+a+"("+s.join()+", 0);\n        --"+s[i-2]+";":"\n        "+o+" sourceLocR = coords;\n        ++"+s[(f=i)-1]+";\n        "+o+" sourceLocG = coords;\n        ++"+s[i-2]+";\n        "+o+" sourceLocA = coords;\n        --"+s[i-1]+";\n        "+o+" sourceLocB = coords;\n        --"+s[i-2]+";",["x","y","z","w","u","v"].slice(0,f)),l="."+u[f-1],d=u.map(function(e){return"int "+e}),c=v("sourceLocR",f-1).concat("inIdx.r"),p=v("sourceLocG",f-1).concat("inIdx.g"),h=v("sourceLocB",f-1).concat("inIdx.b"),f=v("sourceLocA",f-1).concat("inIdx.a"),x="max"===t?"greaterThan":"lessThan",g=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+c.join()+"),\n                             getBestIndicesAChannel("+p.join()+"),\n                             getBestIndicesAChannel("+h.join()+"),\n                             getBestIndicesAChannel("+f.join()+")));",c="vec4(\n            getAChannel("+c.join()+"),\n            hasNextCol ? getAChannel("+p.join()+") : 0.,\n            hasNextRow ? getAChannel("+h.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+f.join()+") : 0.)",p=r?"":"\n      float getBestIndicesAChannel("+d.join()+") {\n        return getChannel(getBestIndicesA("+u.join()+"),\n                                          vec2("+u.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+d.join()+") {\n        return getChannel(getA("+u.join()+"),\n                               vec2("+u.slice(-2).join()+"));\n      }\n      "+p+"\n      void main() {\n        "+o+" coords = getOutputCoords();\n        bool hasNextCol = "+s[i-1]+" < "+(e[i-1]-1)+";\n        bool hasNextRow = "+s[i-2]+" < "+(e[i-2]-1)+";\n        "+a+"\n        ivec4 srcIdx = ivec4(sourceLocR"+l+", sourceLocG"+l+",\n          sourceLocB"+l+", sourceLocA"+l+") * "+n+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+c+";\n\n        for (int i = 0; i < "+n+"; i++) {\n          inIdx = srcIdx;\n          "+g+"\n          vec4 candidate = "+c+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+x+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "};function wr(n,e,t,r){var a,i,t=[t];return D.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),t,e.shape.length),!D.env().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2?(a=[],i=(t=D.backend_util.computeOutAndReduceShapes(e.shape,t))[0],t=t[1],t=D.util.sizeFromShape(t),t=O({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}}),a.push(t),t=function e(n,t,r,a){var i=t.shape[0],o=t.shape[1],s=(null!=(a=void 0===a?null:a)&&(i=a.shape[0],o=a.shape[1]),D.backend_util.computeOptimalWindowSize(o)),i={windowSize:s,inSize:o,batchSize:i,outSize:Math.ceil(o/s)},o=new kr(i,r,null==a),s=[t],i=(null!=a&&s.push(a),n.runWebGLProgram(o,s,"int32"));return 1===i.shape[1]?i:(a=e(n,t,r,i),n.disposeIntermediateTensorInfo(i),a)}(n,t,r),a.push(t),t=O({inputs:{x:t},backend:n,attrs:{shape:i}}),a.forEach(function(e){return n.disposeIntermediateTensorInfo(e)}),t):function e(n,t,r,a){var i=(null!=(a=void 0===a?null:a)?a:t).shape,o=i[i.length-1],o=D.backend_util.computeOptimalWindowSize(o),i=new Ir(i,o,r,null==a),o=n.runWebGLProgram(i,null==a?[t]:[t,a],"int32");return o.shape.length===t.shape.length?(i=e(n,t,r,o),n.disposeIntermediateTensorInfo(o),i):o}(n,e,r)}var Rr={kernelName:D.ArgMax,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,e=e.axis,e=D.util.parseAxisParam(e,n.shape),r=D.backend_util.getAxesPermutation(e,n.shape.length),a=n,i=[],n=(null!=r&&(a=M({inputs:{x:n},backend:t,attrs:{perm:r}}),i.push(a),e=D.backend_util.getInnerMostAxes(e.length,a.shape.length)),D.backend_util.assertAxesAreInnerMostDims("argMax",[e[0]],a.shape.length),wr(t,a,e[0],"max"));return i.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),n}};var Tr={kernelName:D.ArgMin,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,e=e.axis,e=D.util.parseAxisParam(e,n.shape),r=D.backend_util.getAxesPermutation(e,n.shape.length),a=n,i=[],n=(null!=r&&(a=M({inputs:{x:n},backend:t,attrs:{perm:r}}),i.push(a),e=D.backend_util.getInnerMostAxes(e.length,a.shape.length)),D.backend_util.assertAxesAreInnerMostDims("argMin",[e[0]],a.shape.length),wr(t,a,e[0],"min"));return i.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),n}},Nr=R({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Nr={kernelName:D.Asin,backendName:"webgl",kernelFunc:Nr},Er=R({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Er={kernelName:D.Asinh,backendName:"webgl",kernelFunc:Er},Sr=R({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Sr={kernelName:D.Atan,backendName:"webgl",kernelFunc:Sr},Ar=T({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Ar={kernelName:D.Atan2,backendName:"webgl",kernelFunc:Ar},Fr=R({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Fr={kernelName:D.Atanh,backendName:"webgl",kernelFunc:Fr},_r=function(e,n,t,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");var i=e.filterWidth,o=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left,f=(this.outputShape=e.outShape,"avg"===n),x="((batch  * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + d",g="(xR * "+e.inWidth+" + xC) * "+e.inChannels+" + d",m=f?"0.0":"-1.0 / 1e-20";t?this.userCode="\n        const ivec2 strides = ivec2("+o+", "+s+");\n        const ivec2 pads = ivec2("+p+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+d+";\n              wR += "+u+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+c+";\n                wC += "+l+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = "+(r?a?x:g:"wR * "+c+" + wC")+";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ":(t="avg"===n?"avgValue / count":n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])",r=4*Math.floor(i/4),this.userCode="\n      const ivec2 strides = ivec2("+o+", "+s+");\n      const ivec2 pads = ivec2("+p+", "+h+");\n      const float initializationValue = "+m+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+e.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+m+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+d+";\n            wR += "+u+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+r+"; wC += 4) {\n            int xC = xCCorner + wC * "+l+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              getValue(batch, xR, xC + 2 * "+l+", d),\n              getValue(batch, xR, xC + 3 * "+l+", d)\n            );\n\n            "+(a="\n      if ("+f+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ")+"\n          }\n\n          int xC = xCCorner + "+r+";\n          if ("+(1==(x=i%4))+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+a+"\n          } else if ("+(2==x)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+a+"\n          } else if ("+(3==x)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+l+", d),\n              getValue(batch, xR, xC + 2 * "+l+", d),\n              initializationValue\n            );\n\n            "+a+"\n          }\n        }\n        setOutput("+t+");\n      }\n    ")},Or=function(e,n,t,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");var i=e.filterWidth,o=e.strideDepth,s=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,d=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,g=e.padInfo.top,m=e.padInfo.left,v=(this.outputShape=e.outShape,"avg"===n),b=v?"0.0":"-1.0 / 1e-20";t?this.userCode="\n        const ivec3 strides =\n            ivec3("+o+", "+s+", "+u+");\n        const ivec3 pads = ivec3("+x+", "+g+", "+m+");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < "+p+";\n              wD += "+l+") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= "+e.inDepth+") {\n              continue;\n            }\n\n            for (int wR = 0; wR < "+h+";\n                wR += "+d+") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= "+e.inHeight+") {\n                continue;\n              }\n\n              for (int wC = 0; wC < "+f+";\n                  wC += "+c+") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= "+e.inWidth+") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = "+(r?a?"(((batch * "+e.inDepth+" + xD) * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + ch":"((xD * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + ch":"wD * "+h+" * "+f+" +\n                      wR * "+f+" + wC")+";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ":(t="avg"===n?"avgValue / count":n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])",r=4*Math.floor(i/4),this.userCode="\n      const ivec3 strides =\n        ivec3("+o+", "+s+", "+u+");\n      const ivec3 pads = ivec3("+x+", "+g+", "+m+");\n      const float initializationValue = "+b+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= "+e.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+b+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < "+p+";\n            wD += "+l+") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= "+e.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+";\n            wR += "+d+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+r+"; wC += 4) {\n              int xC = xCCorner + wC * "+c+";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                getValue(batch, xD, xR, xC + 3 * "+c+", ch)\n              );\n\n              "+(a="\n      if ("+v+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ")+"\n            }\n\n            int xC = xCCorner + "+r+";\n            if ("+(1==(f=i%4))+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              "+a+"\n            } else if ("+(2==f)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              "+a+"\n            } else if ("+(3==f)+") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + "+c+", ch),\n                getValue(batch, xD, xR, xC + 2 * "+c+", ch),\n                initializationValue\n              );\n\n              "+a+"\n            }\n          }\n          setOutput("+t+");\n        }\n      }\n    ")};var Dr={kernelName:D.AvgPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=(u(n=n.x,"avgPool"),e.filterSize),a=e.strides,i=e.pad,e=e.dimRoundingMode;return D.util.assert(D.backend_util.eitherStridesOrDilationsAreOne(a,1),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '1'"}),1===(r=D.backend_util.computePool2DInfo(n.shape,r,a,1,i,e)).filterWidth&&1===r.filterHeight&&D.util.arraysEqual(r.inShape,r.outShape)?I({inputs:{x:n},backend:t}):(i=new _r(r,"avg",!1),t.runWebGLProgram(i,[n],"float32"))}};var Lr={kernelName:D.AvgPool3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.filterSize,a=e.strides,i=e.pad,o=e.dimRoundingMode,e=e.dataFormat,r=D.backend_util.computePool3DInfo(n.shape,r,a,[1,1,1],i,o,e),a=new Or(r,"avg",!1);return t.runWebGLProgram(a,[n],"float32")}},Pr=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,d=u-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+l+", "+d+");\n      const float avgMultiplier = float("+1/(n*t)+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+i+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+o+") {\n            float dyC = float(dyCCorner + wC) / "+a+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Br=function(e){this.variableNames=["dy"],this.outputShape=e.inShape;var n=e.filterDepth,t=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=d-1-e.padInfo.front,f=c-1-e.padInfo.top,x=p-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+h+", "+f+", "+x+");\n      const float avgMultiplier = float("+1/(n*t*r)+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+d+";\n            wD += "+s+") {\n          float dyD = float(dyDCorner + wD) / "+a+".0;\n\n          if (dyD < 0.0 || dyD >= "+e.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+c+";\n              wR += "+u+") {\n            float dyR = float(dyRCorner + wR) / "+i+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+p+";\n                wC += "+l+") {\n              float dyC = float(dyCCorner + wC) / "+o+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "};var Vr={kernelName:D.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,n=n.input,a=e.filterSize,i=e.strides,o=e.pad,e=e.dimRoundingMode,a=D.backend_util.computePool3DInfo(n.shape,a,i,[1,1,1],o,e),i=new Br(a);return t.runWebGLProgram(i,[r],n.dtype)}};var Wr={kernelName:D.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,a=n=n.input,n=(u([r,n],"avgPoolGrad"),e.filterSize),i=e.strides,e=e.pad,n=D.backend_util.computePool2DInfo(a.shape,n,i,1,e),i=new Pr(n);return t.runWebGLProgram(i,[r],a.dtype)}};var Mr={kernelName:D.BatchMatMul,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs;return cr({a:n.a,b:n.b,transposeA:e.transposeA,transposeB:e.transposeB,backend:t})}},Gr=function(e,n,t,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],D.backend_util.assertAndGetBroadcastShape(e,n),D.backend_util.assertAndGetBroadcastShape(e,t),n="0.0",null!=r&&(D.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),n="getOffsetAtOutCoords()"),t="1.0",null!=a&&(D.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),t="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+n+";\n        float scale = "+t+";\n        float inv = scale * inversesqrt(variance + float("+i+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "},Ur=function(e,n,t,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],D.backend_util.assertAndGetBroadcastShape(e,n),D.backend_util.assertAndGetBroadcastShape(e,t),n="vec4(0.0)",null!=r&&(D.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),n="getOffsetAtOutCoords()"),t="vec4(1.0)",null!=a&&(D.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),t="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = "+n+";\n        vec4 scale = "+t+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+i+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "},zr={kernelName:D.FusedBatchNorm,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,a=n.mean,i=n.variance,o=n.offset,n=n.scale,e=(D.util.assert(a.shape.length===i.shape.length,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),D.util.assert(null==o||a.shape.length===o.shape.length,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),D.util.assert(null==n||a.shape.length===n.shape.length,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),e.varianceEpsilon),s=(null==e&&(e=.001),[r,a,i]),u=null,o=(null!=o&&(u=o.shape,s.push(o)),null),n=(null!=n&&(o=n.shape,s.push(n)),new(D.env().getBool("WEBGL_PACK_NORMALIZATION")?Ur:Gr)(r.shape,a.shape,i.shape,u,o,e));return t.runWebGLProgram(n,s,s[0].dtype)}},Xr=(Hr.prototype.getCustomSetupFunc=function(t){var r=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(e,n){null==r.startLoc&&(r.startLoc=e.getUniformLocationNoThrow(n,"start"),null==r.startLoc)||e.gl.uniform1iv(r.startLoc,t)}},Hr);function Hr(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;var n=m(this.rank),t="uniform int start["+this.rank+"];",r=function(e){{if(1===e)return"sourceLoc";if(e<=6)return jr.slice(0,e).map(function(e){return"sourceLoc."+e}).join(",");throw Error("Slicing for rank "+e+" is not yet supported")}}(this.rank),n="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+e.map(function(e,n){return"sourceLoc."+jr[n]+" = start["+n+"] + coords."+jr[n]+";"}).join("\n")+"\n      ";this.userCode="\n      "+t+"\n      void main() {\n        "+n+"\n        setOutput(getSource("+r+"));\n      }\n    "}var jr=["x","y","z","w","u","v"];qr.prototype.getCustomSetupFunc=function(t){var r=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(e,n){null==r.startLoc&&(r.startLoc=e.getUniformLocationNoThrow(n,"start"),null==r.startLoc)||e.gl.uniform1iv(r.startLoc,t)}};var Kr=qr;function qr(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;var n=m(this.rank),t=v("coords",this.rank),r=v("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+a+")",i="\n      result.x = "+a+";\n      if (++"+t[this.rank-1]+" < "+e[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",a=1===this.rank?"":"\n      --"+t[this.rank-1]+";\n      if (++"+t[this.rank-2]+" < "+e[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+t[this.rank-1]+" < "+e[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",e=this.rank<=4?"sourceLoc = coords +\n            "+n+"("+e.map(function(e,n){return"start["+n+"]"}).join()+");":e.map(function(e,n){return r[n]+" = "+t[n]+" + start["+n+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+n+" coords = getOutputCoords();\n        "+n+" sourceLoc;\n        "+e+"\n        vec4 result = vec4(0.);\n        "+i+"\n        "+a+"\n        setOutput(result);\n      }\n    "}function Yr(e){var n,t,r,a=e.inputs,i=e.backend,e=e.attrs,a=a.x,o=e.begin,e=e.size,o=D.slice_util.parseSliceParams(a,o,e),e=o[0],o=o[1];return D.slice_util.assertParamsValid(a,e,o),0===D.util.sizeFromShape(o)?i.makeTensorInfo(o,a.dtype,[]):i.shouldExecuteOnCPU([a])||"string"===a.dtype?(n=i.texData.get(a.dataId),n=qn(n.values,e,o,a.shape,a.dtype),i.makeTensorInfo(o,a.dtype,n)):(n=i.texData.get(a.dataId).isPacked,t=D.slice_util.isSliceContinous(a.shape,e,o),n||!t?(t=(n=new(D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?Kr:Xr)(o)).getCustomSetupFunc(e),i.runWebGLProgram(n,[a],a.dtype,t)):(i.uploadToGPU(a.dataId),n=a,t=e,a=o,o=(e=i).texData.get(n.dataId),i=e.makeTensorInfo(a,n.dtype),r=e.texData.get(i.dataId),Object.assign(r,o),r.refCount=1,r.shape=a,r.dtype=n.dtype,a=D.slice_util.computeFlatOffset(t,D.util.computeStrides(n.shape)),o.slice&&(a+=o.slice.flatOffset),r.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||n.dataId},t=e.dataRefCount.get(r.slice.origDataId)||1,e.dataRefCount.set(r.slice.origDataId,t+1),i))}var Qr={kernelName:D.Slice,backendName:"webgl",kernelFunc:Yr},Zr={kernelName:D.BatchToSpaceND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.blockShape,e=e.crops,a=(D.util.assert(n.shape.length<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}),r.reduce(function(e,n){return e*n})),i=D.backend_util.getReshaped(n.shape,r,a),o=D.backend_util.getPermuted(i.length,r.length),a=D.backend_util.getReshapedPermuted(n.shape,r,a),s=D.backend_util.getSliceBeginCoords(e,r.length),e=D.backend_util.getSliceSize(a,e,r.length),r=[],n=O({inputs:{x:n},backend:t,attrs:{shape:i}}),i=M({inputs:{x:n},backend:t,attrs:{perm:o}}),o=O({inputs:{x:i},backend:t,attrs:{shape:a}}),a=Yr({inputs:{x:o},backend:t,attrs:{begin:s,size:e}});return r.push(n),r.push(i),r.push(o),r.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),a}};var $r={kernelName:D.Bincount,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.weights,e=e.size,r=t.readSync(r.dataId),a=t.readSync(n.dataId),r=Pn(r,a,n.dtype,n.shape,e);return t.makeTensorInfo([e],n.dtype,r)}},Jr=T({opSnippet:"return float(a != b);",cpuKernelImpl:_n,dtype:"bool"}),_n={kernelName:D.NotEqual,backendName:"webgl",kernelFunc:Jr};function ea(e){var n=e.inputs,e=e.backend,n=n.input;return I({inputs:{x:e.texData.get(n.dataId).complexTensorInfos.real},backend:e})}var na={kernelName:D.Real,backendName:"webgl",kernelFunc:ea},ta="return float(int(x));";var ra={kernelName:D.Cast,backendName:"webgl",kernelFunc:function e(n){var t,r,a,i,o=n.inputs,s=n.backend,n=n.attrs,o=o.x,n=n.dtype;if("complex64"===n)return"complex64"===o.dtype?I({inputs:{x:o},backend:s}):(t=D.zeros(o.shape),i=w({inputs:{real:r=e({inputs:{x:o},backend:s,attrs:{dtype:"float32"}}),imag:t},backend:s}),t.dispose(),s.disposeIntermediateTensorInfo(r),i);if("complex64"===o.dtype)return i=e({inputs:{x:t=ea({inputs:{input:o},backend:s})},backend:s,attrs:{dtype:n}}),s.disposeIntermediateTensorInfo(t),i;if(!D.util.hasEncodingLoss(o.dtype,n))return{dataId:(i=I({inputs:{x:o},backend:s})).dataId,shape:i.shape,dtype:n};if("int32"===n)return r=s,a=new C((t=o).shape,ta),{dataId:(r=r.runWebGLProgram(a,[t],"int32")).dataId,shape:r.shape,dtype:r.dtype};if("bool"===n)return a=s.makeTensorInfo([],"bool",D.util.getTypedArrayFromDType("bool",1)),i=Jr({inputs:{a:o,b:a},backend:s}),s.disposeIntermediateTensorInfo(a),i;throw new Error("Error in Cast: failed to cast "+o.dtype+" to "+n)}},aa="return ceil(x);",aa=R({opSnippet:aa,packedOpSnippet:aa,cpuKernelImpl:bn}),bn={kernelName:D.Ceil,backendName:"webgl",kernelFunc:aa},ia=(oa.prototype.getCustomSetupFunc=function(t,r){var a=this;return function(e,n){null==a.minLoc&&(a.minLoc=e.getUniformLocationNoThrow(n,"minVal"),a.maxLoc=e.getUniformLocationNoThrow(n,"maxVal")),e.gl.uniform1f(a.minLoc,t),e.gl.uniform1f(a.maxLoc,r)}},oa);function oa(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}ua.prototype.getCustomSetupFunc=function(t,r){var a=this;return function(e,n){null==a.minLoc&&(a.minLoc=e.getUniformLocationNoThrow(n,"minVal"),a.maxLoc=e.getUniformLocationNoThrow(n,"maxVal")),e.gl.uniform1f(a.minLoc,t),e.gl.uniform1f(a.maxLoc,r)}};var sa=ua;function ua(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}var aa={kernelName:D.ClipByValue,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.clipValueMin,e=e.clipValueMax,a=new(D.env().getBool("WEBGL_PACK_CLIP")?sa:ia)(n.shape),r=a.getCustomSetupFunc(r,e);return t.runWebGLProgram(a,[n],n.dtype,r)}},la=function(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "};function da(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}var ca={kernelName:D.ComplexAbs,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,n=n.x,t=e.texData.get(n.dataId),r=new la(n.shape),n=[da(n,t.complexTensorInfos.real),da(n,t.complexTensorInfos.imag)];return e.runWebGLProgram(r,n,n[0].dtype)}},pa=function(e){this.outputShape=[],this.outputShape=D.backend_util.computeOutShape(e,1),this.variableNames=e.map(function(e,n){return"T"+n});var n=new Array(e.length-1);n[0]=e[0][1];for(var t=1;t<n.length;t++)n[t]=n[t-1]+e[t][1];for(var r=["if (yC < "+n[0]+") setOutput(getT0(yR, yC));"],t=1;t<n.length;t++){var a=n[t-1];r.push("else if (yC < "+n[t]+") setOutput(getT"+t+"(yR, yC-"+a+"));")}var i=n.length,o=n[n.length-1];r.push("else setOutput(getT"+i+"(yR, yC-"+o+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "},ha=function(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=D.backend_util.computeOutShape(e,n);var t=this.outputShape,r=t.length,a=m(r),i=v("coords",r),o=["x","y","z","w","u","v"].slice(0,r),s=(this.variableNames=e.map(function(e,n){return"T"+n}),new Array(e.length-1));s[0]=e[0][n];for(var u=1;u<s.length;u++)s[u]=s[u-1]+e[u][n];for(var l=o[n],d=o.slice(-2),c=o.join(),p="if ("+l+" < "+s[0]+") {\n        return getChannel(\n            getT0("+c+"), vec2("+d.join()+"));\n        }",u=1;u<s.length;u++){var h=s[u-1];p+="\n        if ("+l+" < "+s[u]+"  && "+l+" >= "+s[u-1]+") {\n          return getChannel(\n            getT"+u+"("+fa(o,l,h)+"),\n            vec2("+fa(d,l,h)+"));\n        }"}var c=s.length,f=s[s.length-1];p+="\n        return getChannel(\n          getT"+c+"("+fa(o,l,f)+"),\n          vec2("+fa(d,l,f)+"));",this.userCode="\n      float getValue("+o.map(function(e){return"int "+e})+") {\n        "+p+"\n      }\n\n      void main() {\n        "+a+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+i+"), 0., 0., 0.);\n\n        "+i[r-1]+" = "+i[r-1]+" + 1;\n        if ("+i[r-1]+" < "+t[r-1]+") {\n          result.g = getValue("+i+");\n        }\n\n        "+i[r-2]+" = "+i[r-2]+" + 1;\n        if ("+i[r-2]+" < "+t[r-2]+") {\n          result.a = getValue("+i+");\n        }\n\n        "+i[r-1]+" = "+i[r-1]+" - 1;\n        if ("+i[r-2]+" < "+t[r-2]+" &&\n            "+i[r-1]+" < "+t[r-1]+") {\n          result.b = getValue("+i+");\n        }\n        setOutput(result);\n      }\n    "};function fa(e,n,t){var r=e.indexOf(n);return e.map(function(e,n){return n===r?e+" - "+t:e}).join()}function xa(e){var n=e.inputs,e=e.backend,n=n.input;return I({inputs:{x:e.texData.get(n.dataId).complexTensorInfos.imag},backend:e})}var ga={kernelName:D.Imag,backendName:"webgl",kernelFunc:xa};function ma(e,t,r){var n,a,i,o,s,u,l,d=e[0].dtype;return"complex64"===d?(l=e.map(function(e){return ea({inputs:{input:e},backend:r})}),a=e.map(function(e){return xa({inputs:{input:e},backend:r})}),i=w({inputs:{real:u=ma(l,t,r),imag:n=ma(a,t,r)},backend:r}),l.forEach(function(e){return r.disposeIntermediateTensorInfo(e)}),a.forEach(function(e){return r.disposeIntermediateTensorInfo(e)}),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(n),i):(l=r.shouldExecuteOnCPU(e),(l="string"===d||l)?(u=(a=e.map(function(e){var n=D.util.sizeFromShape(e.shape.slice(t));return O({inputs:{x:e},backend:r,attrs:{shape:[-1,n]}})})).map(function(e){return{vals:r.readSync(e.dataId),shape:e.shape}}),n=D.backend_util.computeOutShape(a.map(function(e){return e.shape}),1),i=1===a[0].shape[0],l=Vn(u,n,d,i),u=D.backend_util.computeOutShape(e.map(function(e){return e.shape}),t),n=r.makeTensorInfo(u,d,l),a.forEach(function(e){return r.disposeIntermediateTensorInfo(e)}),n):e.length>D.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")?(i=Math.floor(e.length/2),u=ma(e.slice(0,i),t,r),l=ma(e.slice(i),t,r),a=ma([u,l],t,r),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(l),a):D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&1<e[0].shape.length?(n=new ha(e.map(function(e){return e.shape}),t),r.runWebGLProgram(n,e,d)):(i=e,o=t,s=r,u=D.backend_util.computeOutShape(i.map(function(e){return e.shape}),o),a=(l={tensors2D:i.map(function(e){return O({inputs:{x:e},attrs:{shape:[-1,D.util.sizeFromShape(e.shape.slice(o))]},backend:s})}),outShape:u}).outShape,e=new pa((n=l.tensors2D).map(function(e){return e.shape})),l=r.runWebGLProgram(e,n,d),n.forEach(function(e){return r.disposeIntermediateTensorInfo(e)}),e=O({inputs:{x:l},attrs:{shape:a},backend:r}),r.disposeIntermediateTensorInfo(l),e))}function va(e){var n=e.inputs,t=e.backend,e=e.attrs.axis,e=D.util.parseAxisParam(e,n[0].shape)[0],r=D.backend_util.computeOutShape(n.map(function(e){return e.shape}),e);return 0===D.util.sizeFromShape(r)?t.makeTensorInfo(r,n[0].dtype,[]):1===(r=n.filter(function(e){return 0<D.util.sizeFromShape(e.shape)})).length?I({inputs:{x:r[0]},backend:t}):(n=r.map(function(e){return e.shape}),D.backend_util.assertParamsConsistent(n,e),ma(r,e,t))}var ba={kernelName:D.Concat,backendName:"webgl",kernelFunc:va},Ca=function(e,n,t,r,a){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===r&&(r=!1),void 0===a&&(a=!1),this.variableNames=["x","W"],this.outputShape=e.outShape;var i=e.padInfo.top,o=e.padInfo.left,s=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,d=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,g=x?1:2,m=x?2:3,v=x?3:1,b="",C="",t=(t&&(b=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+t+"\n        }":a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          "+t+"\n        }":"\n          float activation(float x) {\n            "+t+"\n          }\n        ",C="result = activation(result);"),n?"result += getBiasAtOutCoords();":"");n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      "+b+"\n\n      const ivec2 strides = ivec2("+s+", "+u+");\n      const ivec2 pads = ivec2("+i+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords["+v+"];\n\n        ivec2 xRCCorner =\n            ivec2(coords["+g+"], coords["+m+"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+c+"; wR++) {\n          int xR = xRCorner + wR * "+l+";\n\n          if (xR < 0 || xR >= "+e.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+p+"; wC++) {\n            int xC = xCCorner + wC * "+d+";\n\n            if (xC < 0 || xC >= "+e.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+h+"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if ("+x+") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if ("+(1==f)+") {\n\n              if ("+x+") {\n                dotProd +=\n                    getX(batch, xR, xC, "+h+") *\n                    getW(wR, wC, "+h+", d2);\n              } else {\n                dotProd +=\n                    getX(batch, "+h+", xR, xC) *\n                    getW(wR, wC, "+h+", d2);\n              }\n\n            } else if ("+(2==f)+") {\n              vec2 wValues = vec2(\n                getW(wR, wC, "+h+", d2),\n                getW(wR, wC, "+h+" + 1, d2)\n              );\n\n              if ("+x+") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, "+h+"),\n                  getX(batch, xR, xC, "+h+" + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, "+h+", xR, xC),\n                  getX(batch, "+h+" + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if ("+(3==f)+") {\n              vec3 wValues = vec3(\n                getW(wR, wC, "+h+", d2),\n                getW(wR, wC, "+h+" + 1, d2),\n                getW(wR, wC, "+h+" + 2, d2)\n              );\n\n              if ("+x+") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, "+h+"),\n                  getX(batch, xR, xC, "+h+" + 1),\n                  getX(batch, xR, xC, "+h+" + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, "+h+", xR, xC),\n                  getX(batch, "+h+" + 1, xR, xC),\n                  getX(batch, "+h+" + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        "+t+"\n        "+C+"\n        setOutput(result);\n      }\n    "},ya=function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var n=e.padInfo.front,t=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,d=e.filterDepth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+a+", "+i+", "+o+");\n      const ivec3 pads = ivec3("+n+", "+t+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+d+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+e.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+c+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+p+"; wC++) {\n              int xC = xCCorner + wC * "+l+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+h+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1==f)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+h+") *\n                  getW(wF, wR, wC, "+h+", d2);\n              } else if ("+(2==f)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+h+"),\n                  getX(batch, xF, xR, xC, "+h+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+h+", d2),\n                  getW(wF, wR, wC, "+h+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3==f)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+h+"),\n                  getX(batch, xF, xR, xC, "+h+" + 1),\n                  getX(batch, xF, xR, xC, "+h+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+h+", d2),\n                  getW(wF, wR, wC, "+h+" + 1, d2),\n                  getW(wF, wR, wC, "+h+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},ka=function(e,n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;for(var r=t.filterWidth,a=t.inChannels,i=t.strideWidth,o=t.strideHeight,s=t.padInfo,u=t.outWidth,l=t.dilationWidth,d=t.dilationHeight,t=t.dataFormat,c=s.left,p=s.top,h=a*r,s=k(),f="channelsLast"===t,x=f?0:1,g=f?1:2,m="",v=0;v<=1;v++)for(var b=0;b<=1;b++)m+="\n          blockIndex = rc.y + "+b+";\n          pos = rc.x + "+v+";\n\n          if(blockIndex < "+e[1]+" && pos < "+e[0]+") {\n            offsetY = int(blockIndex / ("+u+")) * "+o+" - "+p+";\n            d0 = offsetY + "+d+" * (pos / "+h+");\n\n            if(d0 < "+n[x]+" && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), "+u+".) * "+i+". - "+c+".);\n              d1 = offsetX + "+l+" * (int(mod(float(pos), "+h+".) / "+a+".));\n\n              if(d1 < "+n[g]+" && d1 >= 0) {\n\n                ch = int(mod(float(pos), "+a+".));\n\n                if ("+f+") {\n                  innerDims = vec2(d1, ch);\n                  result["+(2*v+b)+"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result["+(2*v+b)+"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        "+m+"\n\n        "+s.output+" = result;\n      }\n    "};function Ia(e){var n,t,r,a,i=e.x,o=e.filter,s=e.convInfo,u=e.backend,l=e.bias,l=void 0===l?null:l,d=e.preluActivationWeights,d=void 0===d?null:d,c=e.leakyreluAlpha,c=void 0===c?0:c,e=e.activation,e=void 0===e?null:e,p=i.shape,h=u.texData.get(i.dataId),f=s.inChannels,x=p[0]*p[1]*p[2],g=s.outChannels,m="channelsLast"===s.dataFormat,v=[],b=p[2]%2!=0&&!!h.isPacked;!((1==x||1===g)&&dr<f)&&D.env().getBool("WEBGL_LAZILY_UNPACK")&&D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&b?(t=m?p[0]*p[1]*(p[2]+1):p[0]*p[2]*(p[3]+1),n={dataId:i.dataId,shape:[1,t,s.inChannels],dtype:i.dtype},x=h.shape,h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,D.util.assert(Ce(h.shape,n.shape),function(){return"packed reshape "+h.shape+" to "+n.shape+" isn't free"}),r=O({inputs:{x:o},backend:u,attrs:{shape:[1,s.inChannels,s.outChannels]}}),v.push(r),g=cr({a:n,b:r,backend:u,transposeA:!1,transposeB:!1,bias:l,activation:e,preluActivationWeights:d,leakyreluAlpha:c}),f=u.texData.get(g.dataId),D.util.assert(f.isPacked,function(){return"batchMatMul result is expected to be packed"}),h.shape=x,f.shape=s.outShape,(a=I({inputs:{x:g},backend:u})).shape=s.outShape,v.push(g)):(x=cr({a:b=O({inputs:{x:i},backend:u,attrs:{shape:[1,t=m?p[0]*p[1]*p[2]:p[0]*p[2]*p[3],s.inChannels]}}),b:r=O({inputs:{x:o},backend:u,attrs:{shape:[1,s.inChannels,s.outChannels]}}),transposeA:!1,transposeB:!1,backend:u,bias:l,activation:e,preluActivationWeights:d,leakyreluAlpha:c}),a=O({inputs:{x:x},backend:u,attrs:{shape:s.outShape}}),v.push(b),v.push(r),v.push(x));for(var C=0,y=v;C<y.length;C++)u.disposeIntermediateTensorInfo(y[C]);return a}function wa(e){var n=e.x,t=e.filter,r=e.convInfo,a=e.backend,i=e.bias,i=void 0===i?null:i,o=e.preluActivationWeights,o=void 0===o?null:o,s=e.leakyreluAlpha,s=void 0===s?0:s,e=e.activation,e=void 0===e?null:e,u=r.filterWidth,l=r.filterHeight,d=r.inChannels,c=r.outWidth,p=r.outHeight,h="channelsLast"===r.dataFormat,u=u*l*d,l=p*c,d=[u,l],f=[],n=O({inputs:{x:n},backend:a,attrs:{shape:n.shape.slice(1)}}),t=O({inputs:{x:t},backend:a,attrs:{shape:[1,u,D.util.sizeFromShape(t.shape)/u]}}),u=(f.push(n),f.push(t),new ka(d,n.shape,r)),u=a.runWebGLProgram(u,[n],"float32"),n=O({inputs:{x:u},backend:a,attrs:{shape:[1,d[0],d[1]]}}),d=(f.push(u),f.push(n),null!=i),u=null!=o,x="leakyrelu"===e,e=e?qt(e,!0):null,l=new Yt(n.shape,t.shape,[1,l,r.outChannels],!0,!1,d,e,u,x),d=[n,t],n=(i&&d.push(i),u&&d.push(o),x&&(e=a.makeTensorInfo([],"float32",D.util.createScalarValue(s,"float32")),d.push(e),f.push(e)),a.runWebGLProgram(l,d,"float32")),t=O({inputs:{x:n},backend:a,attrs:{shape:h?[1,p,c,r.outChannels]:[1,r.outChannels,p,c]}});f.push(n);for(var g=0,m=f;g<m.length;g++)a.disposeIntermediateTensorInfo(m[g]);return t}var Ra={kernelName:D.Conv2D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.filter,a=e.strides,i=e.pad,o=e.dataFormat,s=e.dilations,e=e.dimRoundingMode,o=D.backend_util.convertConv2DDataFormat(o),a=D.backend_util.computeConv2DInfo(r.shape,n.shape,a,s,i,e,!1,o),e=O({inputs:{x:i=1!==a.filterHeight||1!==a.filterWidth||1!==a.dilationHeight||1!==a.dilationWidth||1!==a.strideHeight||1!==a.strideWidth||"SAME"!==a.padInfo.type&&"VALID"!==a.padInfo.type?D.env().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0]?wa({x:r,filter:n,convInfo:a,backend:t}):(s=new Ca(a),t.runWebGLProgram(s,[r,n],"float32")):Ia({x:r,filter:n,convInfo:a,backend:t})},backend:t,attrs:{shape:a.outShape}});return t.disposeIntermediateTensorInfo(i),e}},Ta=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideHeight,t=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+n+" - "+r+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+t+" - "+a+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              if ("+i+") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Na=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i="channelsLast"===e.dataFormat,o=n-1-e.padInfo.top,s=t-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+o+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords["+(i?3:1)+"];\n\n        ivec2 dyCorner = ivec2(coords["+(i?1:2)+"], coords["+(i?2:3)+"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+n+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+n+" - 1 - wR;\n\n          for (int wC = 0; wC < "+t+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+a+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+t+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+e.outChannels+"; d2++) {\n\n              if ("+i+") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Ea=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideDepth,t=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yF = 0; yF < "+e.outDepth+"; yF++) {\n            int xF = wF + yF * "+n+" - "+a+";\n\n            if (xF < 0 || xF >= "+e.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n              int xR = wR + yR * "+t+" - "+i+";\n\n              if (xR < 0 || xR >= "+e.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+o+";\n\n                if (xC < 0 || xC >= "+e.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Sa=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterDepth,t=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=n-1-e.padInfo.front,u=t-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+l+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+n+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+a+".0;\n\n          if (dyF < 0.0 || dyF >= "+e.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+n+" - 1 - wF;\n\n          for (int wR = 0; wR < "+t+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+i+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+t+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+o+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+e.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "};var Aa={kernelName:D.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.dy,a=e.strides,i=e.pad,o=e.dataFormat,s=e.dimRoundingMode,e=e.filterShape,o=D.backend_util.convertConv2DDataFormat(o),e=D.backend_util.computeConv2DInfo(r.shape,e,a,1,i,s,!1,o),a=new Ta(e);return t.runWebGLProgram(a,[r,n],"float32")}};var Fa={kernelName:D.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,n=n.filter,a=e.inputShape,i=e.strides,o=e.pad,s=e.dataFormat,e=e.dimRoundingMode,s=D.backend_util.convertConv2DDataFormat(s),a=D.backend_util.computeConv2DInfo(a,n.shape,i,1,o,e,!1,s),i=new Na(a);return t.runWebGLProgram(i,[r,n],"float32")}};var _a={kernelName:D.Conv3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.filter,a=e.strides,i=e.pad,e=e.dilations,a=D.backend_util.computeConv3DInfo(r.shape,n.shape,a,e,i),e=new ya(a);return t.runWebGLProgram(e,[r,n],"float32")}};var Oa={kernelName:D.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.dy,a=e.strides,i=e.pad,e=e.filterShape,e=D.backend_util.computeConv3DInfo(r.shape,e,a,1,i),a=new Ea(e);return t.runWebGLProgram(a,[r,n],"float32")}};var Da={kernelName:D.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,n=n.filter,a=e.pad,i=e.strides,e=e.inputShape,e=D.backend_util.computeConv3DInfo(e,n.shape,i,1,a),i=new Sa(e);return t.runWebGLProgram(i,[r,n],"float32")}},La=R({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),La={kernelName:D.Cos,backendName:"webgl",kernelFunc:La},Pa=R({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Pa={kernelName:D.Cosh,backendName:"webgl",kernelFunc:Pa},Ba=function(e,n,t,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var i=e[0],o=e[1],s=e[2],e=e[3],n=n[0],u=t[0],t=t[1],n=(this.outputShape=[n,u,t,e],"bilinear"===r?1:0),r=(e=[o-1+".0",s-1+".0"])[0],e=e[1],o=1<u?[""+(o-1)/(u-1),"(y2-y1) * height_ratio","y1*"+r+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+r],u=1<t?[""+(s-1)/(t-1),"(x2-x1) * width_ratio","x1*"+e+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+e];this.userCode="\n      const float height_ratio = float("+o[0]+");\n      const float width_ratio = float("+u[0]+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+i+") {\n          return;\n        }\n\n        float height_scale = "+o[1]+";\n        float width_scale = "+u[1]+";\n\n        float in_y = "+o[2]+";\n        if( in_y < 0.0 || in_y > "+r+" ) {\n          setOutput(float("+a+"));\n          return;\n        }\n        float in_x = "+u[2]+";\n        if( in_x < 0.0 || in_x > "+e+" ) {\n          setOutput(float("+a+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+n+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "},Va={kernelName:D.CropAndResize,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.image,a=n.boxes,n=n.boxInd,i=e.cropSize,o=e.method,e=e.extrapolationValue,i=new Ba(r.shape,a.shape,i,o,e);return t.runWebGLProgram(i,[r,a,n],"float32")}},Wa=(Ma.prototype.getCustomSetupFunc=function(t){var r=this;return function(e,n){null==r.index&&(r.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(r.index,t)}},Ma);function Ma(e,n,t){this.variableNames=["x"];var r=(this.outputShape=e).length,a=n?"0.0":"getX("+Ga(r,"coords")+")",e=e[e.length-1],i="",o="",o=n?(i=t?"end != "+(e-1):"end != 0",t?"end + 1":"end - 1"):(i=t?"end + pow2 < "+e:"end >= pow2",t?"end + pow2":"end - pow2");this.userCode="\n      uniform float index;\n      void main() {\n        "+m(r)+" coords = getOutputCoords();\n        int end = "+Ua(r,"coords")+";\n        float val = "+a+";\n        int pow2 = int(pow(2.0, index));\n        if ("+i+") {\n          int idx = "+o+";\n          "+Ua(r,"coords")+" = idx;\n          val += getX("+Ga(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}function Ga(e,n){if(1===e)return""+n;if(2===e)return n+".x, "+n+".y";if(3===e)return n+".x, "+n+".y, "+n+".z";if(4===e)return n+".x, "+n+".y, "+n+".z, "+n+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}function Ua(e,n){if(1===e)return""+n;if(2===e)return n+".y";if(3===e)return n+".z";if(4===e)return n+".w";throw Error("Cumulative sum for rank "+e+" is not yet supported")}var za={kernelName:D.Cumsum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.axis,a=e.exclusive,i=e.reverse,e=n.shape.length,o=D.backend_util.getAxesPermutation([r],e),s=n,u=(null!=o&&(s=M({inputs:{x:n},backend:t,attrs:{perm:o}})),D.backend_util.getInnerMostAxes(1,e)[0]);if(u!==e-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(n.shape.length-1)+" but got axis="+r);for(var l=s.shape[u],d=I({inputs:{x:s},backend:t}),c=0;c<=Math.ceil(Math.log2(l))-1;c++){var p,h=(p=new Wa(s.shape,!1,i)).getCustomSetupFunc(c),f=d,d=t.runWebGLProgram(p,[d],d.dtype,h);t.disposeIntermediateTensorInfo(f)}return a&&(p=new Wa(s.shape,a,i),f=d,d=t.runWebGLProgram(p,[d],d.dtype),t.disposeIntermediateTensorInfo(f)),null!=o?(e=M({inputs:{x:d},backend:t,attrs:{perm:D.backend_util.getUndoAxesPermutation(o)}}),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(s),e):d}};var Xa={kernelName:D.DenseBincount,backendName:"webgl",kernelFunc:function(e){var n,t,r=e.inputs,a=e.backend,e=e.attrs,i=r.x,r=r.weights,o=e.size,e=e.binaryOutput;if(1===i.shape.length)return n=a.readSync(i.dataId),t=a.readSync(r.dataId),n=Pn(n,t,r.dtype,r.shape,o),a.makeTensorInfo([o],r.dtype,n);if(2===i.shape.length)return t=a.bufferSync(i),n=a.bufferSync(r),t=Bn(t,n,o,e),a.makeTensorInfo(t.shape,r.dtype,t.values);throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+i.shape.length+".")}},Ha=(ja.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},ja.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},ja.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},ja.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},ja.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},ja);function ja(e,n,t){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=t,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+n+";\n      int offset_h = imod(h, "+n+");\n      int in_w = w / "+n+";\n      int offset_w = imod(w, "+n+");\n      int offset_d = (offset_h * "+n+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}var Ka={kernelName:D.DepthToSpace,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.blockSize,e=e.dataFormat,a=(D.util.assert(1<r,function(){return"blockSize should be > 1 for depthToSpace, but was: "+r}),n.shape[0]),i="NHWC"===e?n.shape[1]:n.shape[2],o="NHWC"===e?n.shape[2]:n.shape[3],s="NHWC"===e?n.shape[3]:n.shape[1],i=i*r,o=o*r,s=s/(r*r),a=new Ha("NHWC"===e?[a,i,o,s]:[a,s,i,o],r,e);return t.runWebGLProgram(a,[n],n.dtype)}},qa=function(e,n,t,r,a){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===r&&(r=!1),void 0===a&&(a=!1),this.variableNames=["x","W"],this.outputShape=e.outShape;var i=e.inHeight,o=e.inWidth,s=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,d=e.strideWidth,c=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,e=e.outChannels/e.inChannels,x="",g="",t=(t&&(x=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          "+t+"\n        }":a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          "+t+"\n        }":"\n          float activation(float x) {\n            "+t+"\n          }\n        ",g="result = activation(result);"),n?"result += getBiasAtOutCoords();":"");n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      "+x+"\n\n      const ivec2 strides = ivec2("+l+", "+d+");\n      const ivec2 pads = ivec2("+s+", "+u+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+e+";\n        int q = d2 - d1 * "+e+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+h+"; wR++) {\n          int xR = xRCorner + wR * "+c+";\n\n          if (xR < 0 || xR >= "+i+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+f+"; wC++) {\n            int xC = xCCorner + wC * "+p+";\n\n            if (xC < 0 || xC >= "+o+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        "+t+"\n        "+g+"\n        setOutput(result);\n      }\n    "},Ya=function(e,n,t,r,a){void 0===n&&(n=!1),void 0===t&&(t=null),void 0===r&&(r=!1),void 0===a&&(a=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;for(var i=e.outChannels/e.inChannels,o=e.inHeight,s=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,d=e.strideHeight,c=e.strideWidth,p=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,x=e.filterWidth,g=x,m="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;",v=0;v<x;v++)m+="\n          vec4 xTexelC"+2*v+";\n          int xTexelC"+2*v+"Ready;\n          vec4 xC"+v+";";for(var b=0;b<f;b++){for(v=0;v<x;v++)m+="\n          xTexelC"+2*v+" = vec4(0.0);\n          xTexelC"+2*v+"Ready = 0;\n          xC"+v+" = vec4(0.0);";m+="\n        xR = xRCorner + "+b*p+";\n        if (xR >=0 && xR < "+o+") {\n      ";for(var C=0;C<(g+1)/2;C++){var y,k=2*C;m+="\n          xC = xCCorner + "+(v=k*h)+";\n          ",1===c?k<x&&(l%2==1?m=m+"\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+v+"Ready == 0) {\n                  xTexelC"+v+" = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= "+s+") {\n                    xTexelC"+v+".zw = vec2(0.0);\n                  }\n                  xTexelC"+v+"Ready = 1;\n                }\n              "+(1===h&&0<v?"\n                xC"+k+" = vec4(xTexelC"+(v-2)+".zw, xTexelC"+v+".xy);\n                ":"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < "+s+") {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= "+s+") {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC"+k+" = vec4(previous.zw, xTexelC"+v+".xy);\n                  } else {\n                    xC"+k+" = vec4(0.0, 0.0, xTexelC"+v+".xy);\n                  }\n                  "):m+="\n                if (xC >= 0 && xC < "+s+" && xTexelC"+v+"Ready == 0) {\n                  xTexelC"+v+" = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= "+s+") {\n                    xTexelC"+v+".zw = vec2(0.0);\n                  }\n                  xTexelC"+v+"Ready = 1;\n                }\n\n                xC"+k+" = xTexelC"+v+";\n                ",v+1<x)&&(y=l%2==0?D.util.nearestLargerEven(h):h,h%2==0&&l%2==1||h%2!=0&&l%2!=1?(m+="\n                  xCOffset = xC + "+l%2+" + "+y+";\n\n                  if (xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+(v+2)+"Ready == 0) {\n                    xTexelC"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= "+s+") {\n                      xTexelC"+(v+2)+".zw = vec2(0.0);\n                    }\n                    xTexelC"+(v+2)+"Ready = 1;\n                  }\n                  ",1<h&&(m+="\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+v+"Ready == 0) {\n                      xTexelC"+v+" = getX(batch, xR, xCOffset, d1);\n                      xTexelC"+v+"Ready = 1;\n                    }\n                    "),m+="\n                  xC"+(1+k)+" = vec4(xTexelC"+v+".zw, xTexelC"+(v+2)+".xy);\n                  "):m+=1===y?"\n                    xC"+(1+k)+" = xTexelC"+v+";\n                    ":"\n                    xCOffset = xC + "+y+";\n\n                    if (xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+(v+2)+"Ready == 0) {\n                      xTexelC"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= "+s+") {\n                        xTexelC"+(v+2)+".zw = vec2(0.0);\n                      }\n                      xTexelC"+(v+2)+"Ready = 1;\n                    }\n\n                    xC"+(1+k)+" = xTexelC"+(v+2)+";\n                    "):v<x&&(l%2==1?(m+="\n                xCOffset = xC + 1 - "+c+";\n                if(xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+v+"Ready == 0) {\n                  xTexelC"+v+" = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= "+s+") {\n                    xTexelC"+v+".zw = vec2(0.0);\n                  }\n                  xTexelC"+v+"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+s+" && xTexelC"+(v+2)+"Ready == 0) {\n                  xTexelC"+(v+2)+" = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= "+s+") {\n                    xTexelC"+(v+2)+".zw = vec2(0.0);\n                  }\n                  xTexelC"+(v+2)+"Ready = 1;\n                }\n\n                xC"+k+" = vec4(xTexelC"+v+".zw, xTexelC"+(v+2)+".zw);\n              ",v+1<x&&(m+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + "+c+";\n                  if(xCOffset >= 0 && xCOffset < "+s+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC"+(1+k)+" = vec4(xTexelC"+(v+2)+".xy, final.xy);\n                ")):(m+="\n                if(xC >= 0 && xC < "+s+" && xTexelC"+v+"Ready == 0) {\n                  xTexelC"+v+" = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= "+s+") {\n                    xTexelC"+v+".zw = vec2(0.0);\n                  }\n                  xTexelC"+v+"Ready = 1;\n                }\n\n                xCOffset = xC + "+c+";\n                if(xCOffset >= 0 && xCOffset < "+s+" && xTexelC"+(v+2)+"Ready == 0) {\n                  xTexelC"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= "+s+") {\n                    xTexelC"+(v+2)+".zw = vec2(0.);\n                  }\n                  xTexelC"+(v+2)+"Ready = 1;\n                }\n\n                xC"+k+" = vec4(\n                  xTexelC"+v+".xy, xTexelC"+(v+2)+".xy);\n              ",v+1<x&&(m+="\n                  xC"+(1+k)+" = vec4(xTexelC"+v+".zw, xTexelC"+(v+2)+".zw);\n                "))),k<x&&(m+="\n            wTexel = getW("+b+", "+v+", d1, q);\n            dotProd += xC"+k+" * vec4(wTexel.xz, wTexel.xz);\n          ",v+1<x)&&(m+="\n              wTexel = getW("+b+", "+(v+1)+", d1, q);\n              dotProd += xC"+(1+k)+" * vec4(wTexel.xz, wTexel.xz);\n            ")}m+="\n        }\n      "}var e="",I="",t=(t&&(e=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          "+t+"\n        }":a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          "+t+"\n        }":"vec4 activation(vec4 x) {\n          "+t+"\n        }",I="result = activation(result);"),n?"result += getBiasAtOutCoords();":"");n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      "+e+"\n\n      const ivec2 strides = ivec2("+d+", "+c+");\n      const ivec2 pads = ivec2("+u+", "+l+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+i+";\n        int q = d2 - d1 * "+i+";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        "+m+"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        "+t+"\n        "+I+"\n        setOutput(result);\n      }\n    "};var Qa={kernelName:D.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.filter,a=e.strides,i=e.pad,o=e.dilations,e=e.dimRoundingMode,s=o,o=(null==s&&(s=[1,1]),D.util.assert(D.backend_util.eitherStridesOrDilationsAreOne(a,s),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+s+"'"}),D.backend_util.computeConv2DInfo(r.shape,n.shape,a,s,i,e,!0)),i=new(D.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&o.strideWidth<=2&&o.outChannels/o.inChannels==1?Ya:qa)(o);return t.runWebGLProgram(i,[r,n],"float32")}},Za=function(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;var n=e.strideHeight,t=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+i+" + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < "+e.batchSize+"; b++) {\n          for (int yR = 0; yR < "+e.outHeight+"; yR++) {\n            int xR = wR + yR * "+n+" - "+r+";\n\n            if (xR < 0 || xR >= "+e.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+e.outWidth+"; yC++) {\n              int xC = wC + yC * "+t+" - "+a+";\n\n              if (xC < 0 || xC >= "+e.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},$a=function(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;var n=e.filterHeight,t=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=n-1-e.padInfo.top,o=t-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+n+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+n+" - 1 - wR;\n\n          for (int wC = 0; wC < "+t+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+a+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+t+" - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "};var Ja={kernelName:D.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.dy,a=e.strides,i=e.dilations,o=e.pad,s=e.dimRoundingMode,e=e.filterShape,e=D.backend_util.computeConv2DInfo(r.shape,e,a,i,o,s,!0),a=new Za(e);return t.runWebGLProgram(a,[r,n],"float32")}};var ei={kernelName:D.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,n=n.filter,a=e.strides,i=e.dilations,o=e.pad,s=e.dimRoundingMode,e=e.inputShape,e=D.backend_util.computeConv2DInfo(e,n.shape,a,i,o,s,!0),a=new $a(e);return t.runWebGLProgram(a,[r,n],"float32")}},ni=function(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "};var ti={kernelName:D.Diag,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=(n=n.x).shape.concat(n.shape),r=D.util.sizeFromShape(n.shape),n=O({inputs:{x:n},backend:e,attrs:{shape:[r]}}),r=new ni(r),t=O({inputs:{x:r=e.runWebGLProgram(r,[n],n.dtype)},backend:e,attrs:{shape:t}});return e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(r),t}},ri=function(e){this.variableNames=["x","W"],this.outputShape=e.outShape;var n=e.inHeight,t=e.inWidth,r=e.padInfo,a=e.strideHeight,i=e.strideWidth,o=e.filterHeight,s=e.filterWidth,u=e.dilationHeight,e=e.dilationWidth,l=r.top,r=r.left;this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+l+", "+r+");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < "+o+"; h++) {\n          int hIn = hBeg + h * "+u+";\n\n          if (hIn >= 0 && hIn < "+n+") {\n            for (int w = 0; w < "+s+"; w++) {\n              int wIn = wBeg + w * "+e+";\n\n              if (wIn >= 0 && wIn < "+t+") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    "};var ai={kernelName:D.Dilation2D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.filter,a=e.strides,i=e.pad,e=e.dilations,a=D.backend_util.computeDilation2DInfo(r.shape,n.shape,a,i,"NHWC",e),i=new ri(a),i=O({inputs:{x:e=t.runWebGLProgram(i,[r,n],"float32")},backend:t,attrs:{shape:a.outShape}});return t.disposeIntermediateTensorInfo(e),i}};var ii={kernelName:D.Einsum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs.equation,r=n,a=(n=D.backend_util.decodeEinsumEquation(e,r.length)).allDims,e=n.summedDims,i=n.idDims;D.backend_util.checkEinsumDimSizes(a.length,i,r);for(var o=(n=D.backend_util.getEinsumComputePath(e,i)).path,s=n.steps,u=s.length,l=null,d=a.length,c=[],p=0;p<u;++p){for(var h=0,f=s[p];h<f.length;h++){for(var x=f[h],g=D.backend_util.getEinsumPermutation(d,i[x]),m=g.permutationIndices,v=g.expandDims,g=void 0,b=(D.backend_util.isIdentityPermutation(m)?g=r[x]:(g=M({inputs:{x:r[x]},backend:t,attrs:{perm:m}}),c.push(g)),g.shape.slice()),C=0;C<v.length;++C)b.splice(v[C],0,1);D.util.arraysEqual(g.shape,b)||(g=O({inputs:{x:g},backend:t,attrs:{shape:b}}),c.push(g)),null===l?l=g:(l=Jt({inputs:{a:g,b:l},backend:t}),c.push(l))}p<u-1&&(0<=o[p]&&(l=sr({inputs:{x:l},backend:t,attrs:{axis:o[p]-(a.length-d),keepDims:!1}}),c.push(l)),d--)}for(var y=0,k=c;y<k.length;y++){var I=k[y];I!==l&&t.disposeIntermediateTensorInfo(I)}return l}},oi=R({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),oi={kernelName:D.Elu,backendName:"webgl",kernelFunc:oi},si={kernelName:D.EluGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.dy,n=n.y,r=D.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Wt("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,n.shape):new Vt("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,n.shape);return e.runWebGLProgram(r,[t,n],t.dtype)}},Cn=T({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Cn}),Cn={kernelName:D.Equal,backendName:"webgl",kernelFunc:Cn},ui=R({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '+D.backend_util.ERF_P+";\n  float a1 = "+D.backend_util.ERF_A1+";\n  float a2 = "+D.backend_util.ERF_A2+";\n  float a3 = "+D.backend_util.ERF_A3+";\n  float a4 = "+D.backend_util.ERF_A4+";\n  float a5 = "+D.backend_util.ERF_A5+";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n"}),ui={kernelName:D.Erf,backendName:"webgl",kernelFunc:ui},li="return exp(x);",di=R({opSnippet:li,packedOpSnippet:li,cpuKernelImpl:yn}),li={kernelName:D.Exp,backendName:"webgl",kernelFunc:di};function ci(e){var n=e.inputs,t=e.attrs,e=e.backend,t=t.dim,n=n.input,r=n.shape.length,a=n.shape.slice(),i=t;return t<0&&(D.util.assert(-(r+1)<=t,function(){return"Axis must be in the interval ["+-(r+1)+", "+r+"]"}),i=r+t+1),a.splice(i,0,1),O({inputs:{x:n},backend:e,attrs:{shape:a}})}var yn={kernelName:D.ExpandDims,backendName:"webgl",kernelFunc:ci},pi="return exp(x) - 1.0;",pi=R({opSnippet:pi,packedOpSnippet:pi,cpuKernelImpl:kn}),kn={kernelName:D.Expm1,backendName:"webgl",kernelFunc:pi},hi=function(e,n,t){this.variableNames=["real","imag"];var r,a=n[1],n=(this.outputShape=n,t?"2.0 * "+Math.PI:"-2.0 * "+Math.PI),t=t?a+".0":"1.0";if("real"===e)r="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '+e+".");r="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = "+n+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+r+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+a+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+a+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+t+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "};function fi(e,n,t){var r=t.texData.get(e.dataId),a=D.util.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],a=O({inputs:{x:e},backend:t,attrs:{shape:[a/i,i]}}),i=a.shape,o=new hi("real",i,n),n=new hi("imag",i,n),r=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],i=t.runWebGLProgram(o,r,"float32"),o=t.runWebGLProgram(n,r,"float32"),n=w({inputs:{real:i,imag:o},backend:t}),r=(t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),O({inputs:{x:n},backend:t,attrs:{shape:e.shape}}));return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(n),r}var pi={kernelName:D.FFT,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend;return fi(n.input,!1,e)}},xi=(gi.prototype.getCustomSetupFunc=function(t){var r=this;return function(e,n){null==r.valueLoc&&(r.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(r.valueLoc,t)}},gi);function gi(e,n){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}function mi(e){var n,t=e.backend,e=e.attrs,r=e.shape,a=e.value;return"string"===(e=e.dtype||D.util.inferDtype(a))?((n=D.util.getArrayFromDType(e,D.util.sizeFromShape(r))).fill(a),t.makeTensorInfo(r,e,n)):(r=(n=new xi(r,a)).getCustomSetupFunc(a),t.runWebGLProgram(n,[],e,r))}var vi,bi={kernelName:D.Fill,backendName:"webgl",kernelFunc:mi},Ci=function(e){this.variableNames=["Image"],this.outputShape=[];var n=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = "+n+" - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < "+n+") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "},yi={kernelName:D.FlipLeftRight,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,n=n.image,t=new Ci(n.shape);return e.runWebGLProgram(t,[n],n.dtype)}},ki="return floor(x);",ki=R({opSnippet:ki,packedOpSnippet:ki,cpuKernelImpl:In}),In={kernelName:D.Floor,backendName:"webgl",kernelFunc:ki},ki=T({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),ki={kernelName:D.FloorDiv,backendName:"webgl",kernelFunc:ki},Ii=function(e){this.variableNames=["A"];var n=k(),t=e[0],r=e[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+t+".0);\n\n        vec4 values = "+n.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "},wi=function(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var n=k(),t=e[0],r=e[1];this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2("+r+".0, "+t+".0);\n            vec4 values = "+n.texture2D+"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        "+n.output+" = result;\n      }\n    "},Ri={kernelName:D.FromPixels,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.pixels,e=e.numChannels,r="undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement,i=r?[n.videoWidth,n.videoHeight]:[n.width,n.height],o=i[0],i=i[1],s=[i,o],e=[i,o,e];(a||r)&&((vi=null==vi?document.createElement("canvas").getContext("2d"):vi).canvas.width=o,vi.canvas.height=i,vi.drawImage(n,0,0,o,i),n=vi.canvas);a=t.makeTensorInfo(s,"int32"),t.texData.get(a.dataId).usage=f.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(a.dataId),n),r=new(D.env().getBool("WEBGL_PACK")?wi:Ii)(e),o=t.runWebGLProgram(r,[a],"int32");return t.disposeData(a.dataId),o}};var Ti={kernelName:D.FusedConv2D,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,r=e.backend,e=e.attrs,a=t.x,i=t.filter,o=t.bias,t=t.preluActivationWeights,s=e.strides,u=e.pad,l=e.dataFormat,d=e.dilations,c=e.dimRoundingMode,p=e.activation,e=e.leakyreluAlpha,l=D.backend_util.convertConv2DDataFormat(l),s=D.backend_util.computeConv2DInfo(a.shape,i.shape,s,d,u,c,!1,l),d=[],c=O({inputs:{x:l=1!==s.filterHeight||1!==s.filterWidth||1!==s.dilationHeight||1!==s.dilationWidth||1!==s.strideHeight||1!==s.strideWidth||"SAME"!==s.padInfo.type&&"VALID"!==s.padInfo.type?D.env().getBool("WEBGL_CONV_IM2COL")&&1===a.shape[0]?wa({x:a,filter:i,convInfo:s,backend:r,bias:o,activation:p,preluActivationWeights:t,leakyreluAlpha:e}):(u=null!=o,c=null!=t,l="leakyrelu"===p,n=p?qt(p,!1):null,u=new Ca(s,u,n,c,l),n=[a,i],o&&n.push(o),t&&n.push(t),l&&(c=r.makeTensorInfo([],"float32",D.util.createScalarValue(e,"float32")),n.push(c),d.push(c)),r.runWebGLProgram(u,n,"float32")):Ia({x:a,filter:i,convInfo:s,backend:r,bias:o,activation:p,preluActivationWeights:t,leakyreluAlpha:e})},backend:r,attrs:{shape:s.outShape}});return d.push(l),d.forEach(function(e){return r.disposeIntermediateTensorInfo(e)}),c}};var Ni={kernelName:D.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,a=n.filter,i=n.bias,n=n.preluActivationWeights,o=e.strides,s=e.pad,u=e.dilations,l=e.dimRoundingMode,d=e.activation,e=e.leakyreluAlpha,c=[],p=u,u=(null==p&&(p=[1,1]),D.util.assert(D.backend_util.eitherStridesOrDilationsAreOne(o,p),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+p+"'"}),D.backend_util.computeConv2DInfo(r.shape,a.shape,o,p,s,l,!0)),s=D.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&u.strideWidth<=2&&u.outChannels/u.inChannels==1,l=d?qt(d,s):null,r=[r,a],h=null!=n,d="leakyrelu"===d,e=((a=null!=i)&&r.push(i),h&&r.push(n),d&&(i=t.makeTensorInfo([],"float32",D.util.createScalarValue(e,"float32")),r.push(i),c.push(i)),n=new(s?Ya:qa)(u,a,l,h,d),t.runWebGLProgram(n,r,"float32"));return c.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),e}},Ei=function(e,n,t){this.sliceDim=e,this.strides=n,this.variableNames=["x","indices"],this.outputShape=t,e=m(n.length),n=m(t.length),t=1<this.sliceDim?"strides[j]":"strides",this.userCode="\n        "+e+" strides = "+e+"("+this.strides+");\n         void main() {\n          "+n+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+t+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "};var Si={kernelName:D.GatherNd,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,e=e.backend,r=t.params,t=t.indices,a=(a=t.shape)[a.length-1],i=D.util.sizeFromShape(r.shape),o=(l=D.backend_util.prepareAndValidate(r,t))[0],s=l[1],u=l[2],l=l[3],d=O({inputs:{x:t},backend:e,attrs:{shape:[s,a]}}),c=O({inputs:{x:r},backend:e,attrs:{shape:[D.util.sizeFromShape(r.shape)/u,u]}});return e.shouldExecuteOnCPU([r,t])||"string"===r.dtype?(t=e.readSync(t.dataId),n=e.bufferSync(r),t=Wn(t,n,r.dtype,s,a,u,l,r.shape,i),e.makeTensorInfo(o,r.dtype,t.values)):(n=new Ei(a,l,[s,u]),r=O({inputs:{x:i=e.runWebGLProgram(n,[c,d],c.dtype)},backend:e,attrs:{shape:o}}),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(i),r)}},Ai=function(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length,n=m(this.rank),e=function(e){for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[],r=0;r<e.length;r++)t.push(2===r?"int(getIndices(resRC.x, resRC.z))":""+n[r]);return t.join()}(e),this.userCode="\n      void main() {\n        "+n+" resRC = getOutputCoords();\n        setOutput(getA("+e+"));\n      }\n    "};var Fi={kernelName:D.GatherV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=n.indices,a=e.axis,e=e.batchDims,a=D.util.parseAxisParam(a,r.shape)[0],a=D.backend_util.segment_util.collectGatherOpShapeInfo(r,n,a,e),e=D.util.sizeFromShape(n.shape),i=[],o=O({inputs:{x:r},backend:t,attrs:{shape:[a.batchSize,a.outerSize,a.dimSize,a.sliceSize]}}),s=O({inputs:{x:n},backend:t,attrs:{shape:[a.batchSize,e/a.batchSize]}}),e=(i.push(o),i.push(s),[a.batchSize,a.outerSize,e/a.batchSize,a.sliceSize]);return t.shouldExecuteOnCPU([r,n])||"string"===r.dtype?(n=t.bufferSync(s),r=t.bufferSync(o),r=Mn(r,n,e),i.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),t.makeTensorInfo(a.outputShape,r.dtype,r.values)):(n=new Ai(o.shape,e),r=t.runWebGLProgram(n,[o,s],o.dtype),i.push(r),e=O({inputs:{x:r},backend:t,attrs:{shape:a.outputShape}}),i.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),e)}},wn=T({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:wn,dtype:"bool"}),wn={kernelName:D.Greater,backendName:"webgl",kernelFunc:wn},Rn=T({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Rn}),Rn={kernelName:D.GreaterEqual,backendName:"webgl",kernelFunc:Rn};var _i={kernelName:D.IFFT,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend;return fi(n.input,!0,e)}},Oi=R({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Oi={kernelName:D.IsFinite,backendName:"webgl",kernelFunc:Oi},Di=R({opSnippet:"return float(isinf(x));",dtype:"bool"}),Di={kernelName:D.IsInf,backendName:"webgl",kernelFunc:Di},Li=R({opSnippet:"return float(isnan(x));",dtype:"bool"}),Li={kernelName:D.IsNan,backendName:"webgl",kernelFunc:Li},Tn=T({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Tn,dtype:"bool"}),Tn={kernelName:D.Less,backendName:"webgl",kernelFunc:Tn},Nn=T({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Nn,dtype:"bool"}),Nn={kernelName:D.LessEqual,backendName:"webgl",kernelFunc:Nn};var Pi={kernelName:D.LinSpace,backendName:"webgl",kernelFunc:function(e){var n=e.backend,t=(e=e.attrs).start,r=e.stop,e=e.num,t=Gn(t,r,e);return n.makeTensorInfo([t.length],"float32",t)}},En=R({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:En}),En={kernelName:D.Log,backendName:"webgl",kernelFunc:En},Bi=R({opSnippet:"return log(1.0 + x);"}),Bi={kernelName:D.Log1p,backendName:"webgl",kernelFunc:Bi},Vi=T({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Vi={kernelName:D.LogicalAnd,backendName:"webgl",kernelFunc:Vi},Wi=R({opSnippet:"return float(!(x >= 1.0));"}),Wi={kernelName:D.LogicalNot,backendName:"webgl",kernelFunc:Wi},Mi=T({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Mi={kernelName:D.LogicalOr,backendName:"webgl",kernelFunc:Mi},Gi=function(e,n,t,r,a){this.variableNames=["x"],this.outputShape=[];var i=e[3]-1,e=(this.outputShape=e,"float("+t+") + float("+r+") * sum"),t=.5===a?"inversesqrt("+e+")":1===a?"1.0/("+e+")":"exp(log("+e+") * float(-"+a+"));";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+n+"; j <= "+n+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+i+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+t+";\n        setOutput(val);\n      }\n    "},Ui=function(e,n,t,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var i=e[3]-1,e=(this.outputShape=e,"float("+t+") + float("+r+") * sum"),t=.5===a?"inversesqrt("+e+")":1===a?"1.0/("+e+")":"exp(log("+e+") * float(-"+a+"));";this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+n+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+n+"; j <= "+n+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+i+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+t+";\n        setOutput(result);\n      }\n    "},zi={kernelName:D.LRN,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.depthRadius,a=e.bias,i=e.alpha,e=e.beta,r=new(D.env().getBool("WEBGL_PACK_NORMALIZATION")?Ui:Gi)(n.shape,r,a,i,e);return t.runWebGLProgram(r,[n],n.dtype)}},Xi=function(e,n,t,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=t,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+n+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+n+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+t+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+a+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+a+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "},Hi={kernelName:D.LRNGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,a=n.y,n=n.dy,i=e.depthRadius,o=e.bias,s=e.alpha,e=e.beta,i=new Xi(r.shape,i,o,s,e);return t.runWebGLProgram(i,[r,a,n],r.dtype)}};function ji(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=e.reductionIndices,e=e.keepDims,a=r.shape.length,n=D.util.parseAxisParam(n,r.shape),i=n,o=D.backend_util.getAxesPermutation(i,a),s=null!=o,u=t.shouldExecuteOnCPU([r]),l=r;if(s){if(u){for(var d=t.texData.get(l.dataId).values,c=new Array(a),p=0;p<c.length;p++)c[p]=r.shape[o[p]];var h=at(d,r.shape,r.dtype,o,c),l=t.makeTensorInfo(c,r.dtype);t.texData.get(l.dataId).values=h}else l=or(r,o,t);i=D.backend_util.getInnerMostAxes(i.length,a)}D.backend_util.assertAxesAreInnerMostDims("max",i,a);var f,h=D.backend_util.computeOutAndReduceShapes(l.shape,i),a=h[0],i=h[1],h=a;return e&&(h=D.backend_util.expandShapeToKeepDim(a,n)),u?(d=t.texData.get(l.dataId).values,e=Un(d,D.util.sizeFromShape(i),h,r.dtype),f=t.makeTensorInfo(h,r.dtype),t.texData.get(f.dataId).values=e):(a=l,n=i,u=h,d=t,n=D.util.sizeFromShape(n),n=O({inputs:{x:a},attrs:{shape:[D.util.sizeFromShape(a.shape)/n,n]},backend:d}),a=N(n,a.dtype,"max",d),u=O({inputs:{x:a},attrs:{shape:u},backend:d}),d.disposeIntermediateTensorInfo(n),d.disposeIntermediateTensorInfo(a),f=u),s&&t.disposeIntermediateTensorInfo(l),f}var Ki={kernelName:D.Max,backendName:"webgl",kernelFunc:ji},Sn=T({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Sn}),Sn={kernelName:D.Maximum,backendName:"webgl",kernelFunc:Sn};var qi={kernelName:D.MaxPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=(u(n=n.x,"maxPool"),e.filterSize),a=e.strides,i=e.pad,e=e.dimRoundingMode;return D.util.assert(D.backend_util.eitherStridesOrDilationsAreOne(a,1),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '1'"}),1===(r=D.backend_util.computePool2DInfo(n.shape,r,a,1,i,e)).filterWidth&&1===r.filterHeight&&D.util.arraysEqual(r.inShape,r.outShape)?I({inputs:{x:n},backend:t}):(i=new _r(r,"max",!1),t.runWebGLProgram(i,[n],n.dtype))}};var Yi={kernelName:D.MaxPool3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.filterSize,a=e.strides,i=e.pad,o=e.dataFormat,e=e.dimRoundingMode,r=D.backend_util.computePool3DInfo(n.shape,r,a,[1,1,1],i,e,o),a=new Or(r,"max",!1);return t.runWebGLProgram(a,[n],n.dtype)}},Qi=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var n=e.strideHeight,t=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,s=i-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+o+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+a+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+n+".0;\n\n          if (dyR < 0.0 || dyR >= "+e.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+i+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+t+".0;\n\n            if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+(a*i-1)+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+i+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "},Zi=function(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;var n=e.strideDepth,t=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,d=s-1-e.padInfo.front,c=u-1-e.padInfo.top,p=l-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+d+", "+c+", "+p+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < "+s+";\n           wD += "+a+") {\n          float dyD = float(dyDCorner + wD) / "+n+".0;\n\n          if (dyD < 0.0 || dyD >= "+e.outDepth+".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            float dyR = float(dyRCorner + wR) / "+t+".0;\n\n            if (dyR < 0.0 || dyR >= "+e.outHeight+".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+o+") {\n              float dyC = float(dyCCorner + wC) / "+r+".0;\n\n              if (dyC < 0.0 || dyC >= "+e.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = "+(s*u*l-1)+" -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * "+u+" * "+l+" +\n                  wR * "+l+" + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "};var $i={kernelName:D.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,n=n.input,a=e.filterSize,i=e.strides,o=e.pad,e=e.dimRoundingMode,a=D.backend_util.computePool3DInfo(n.shape,a,i,[1,1,1],o,e),i=new Or(a,"max",!0),o=t.runWebGLProgram(i,[n],n.dtype),e=new Zi(a),i=t.runWebGLProgram(e,[r,o],n.dtype);return t.disposeIntermediateTensorInfo(o),i}};var Ji={kernelName:D.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.dy,a=i=n.input,i=(u([i,n.output],"maxPoolGrad"),e.filterSize),n=e.strides,o=e.pad,e=e.dimRoundingMode,i=D.backend_util.computePool2DInfo(a.shape,i,n,1,o,e),n=new _r(i,"max",!0),o=t.runWebGLProgram(n,[a],a.dtype),e=new Qi(i),n=t.runWebGLProgram(e,[r,o],a.dtype);return t.disposeIntermediateTensorInfo(o),n}};var eo={kernelName:D.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(e){var n,t,r=e.inputs,a=e.attrs,e=e.backend,i=r.x,r=a.filterSize,o=a.strides,s=a.pad,a=a.includeBatchInIndex,u=(D.util.assert(4===i.shape.length,function(){return"Error in maxPool: input must be rank 4 but got rank "+i.shape.length+"."}),[1,1]),r=(D.util.assert(D.backend_util.eitherStridesOrDilationsAreOne(o,u),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+u+"'"}),D.backend_util.computePool2DInfo(i.shape,r,o,u,s)),r=(s=i,a=a,e=e,n=new _r(r=r,"max",!1),t=e.runWebGLProgram(n,[s],"float32"),n=new _r(r,"max",!0,!0,a),[t,e.runWebGLProgram(n,[s],"float32")]);return[r[0],r[1]]}};var no={kernelName:D.Mean,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,e=e.backend,r=n.x,n=t.keepDims,t=t.axis,a=e,e=r.shape.length,t=D.util.parseAxisParam(t,r.shape),i=t,o=D.backend_util.getAxesPermutation(i,e),s=null!=o,u=a.shouldExecuteOnCPU([r]),l=[],d=r;if(s){if(u){for(var s=a.texData.get(d.dataId).values,c=new Array(e),p=0;p<c.length;p++)c[p]=r.shape[o[p]];u=at(s,r.shape,r.dtype,o,c),d=a.makeTensorInfo(c,r.dtype);a.texData.get(d.dataId).values=u}else d=or(r,o,a);l.push(d),i=D.backend_util.getInnerMostAxes(i.length,e)}D.backend_util.assertAxesAreInnerMostDims("sum",i,e);for(var s=D.backend_util.computeOutAndReduceShapes(d.shape,i),u=s[0],e=s[1],i=u,d=(n&&(i=D.backend_util.expandShapeToKeepDim(u,t)),s=d,n=e,u=i,t=a,n=D.util.sizeFromShape(n),s=O({inputs:{x:s},attrs:{shape:[D.util.sizeFromShape(s.shape)/n,n]},backend:t}),n=N(s,"float32","mean",t),u=O({inputs:{x:n},attrs:{shape:u},backend:t}),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(n),u),h=0,f=l;h<f.length;h++){p=f[h];a.disposeIntermediateTensorInfo(p)}return d}};var to={kernelName:D.Min,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.axis,e=e.keepDims,a=n.shape.length,i=r=D.util.parseAxisParam(r,n.shape),o=D.backend_util.getAxesPermutation(i,a),s=n;null!=o&&(s=M({inputs:{x:n},backend:t,attrs:{perm:o}}),i=D.backend_util.getInnerMostAxes(i.length,n.shape.length)),D.backend_util.assertAxesAreInnerMostDims("min",i,a);a=(n=D.backend_util.computeOutAndReduceShapes(s.shape,i))[0],i=n[1],i=N(n=O({inputs:{x:s},backend:t,attrs:{shape:[-1,D.util.sizeFromShape(i)]}}),n.dtype,"min",t);return e=O(e?{inputs:{x:i},backend:t,attrs:{shape:D.backend_util.expandShapeToKeepDim(a,r)}}:{inputs:{x:i},backend:t,attrs:{shape:a}}),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),null!=o&&t.disposeIntermediateTensorInfo(s),e}},An=T({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:An}),An={kernelName:D.Minimum,backendName:"webgl",kernelFunc:An},ro=function(t,e,n){this.variableNames=["x"],this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r=t.length,a=m(r),i=e.map(function(e){return e[0]}).join(","),e=e.map(function(e,n){return e[0]+t[n]}).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),n="reflect"===n?0:1;this.userCode=1===r?"\n        int start = "+i+";\n        int end = "+e+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - "+n+";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + "+n+";\n          }\n          setOutput(getX(outC - start));\n        }\n      ":"\n      "+a+" start = "+a+"("+i+");\n      "+a+" end = "+a+"("+e+");\n\n      void main() {\n        "+a+" outC = getOutputCoords();\n        for (int i = 0; i < "+r+"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - "+n+";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + "+n+";\n          }\n        }\n        "+a+" coords = outC - start;\n        setOutput(getX("+o+"));\n      }\n    "},ao=function(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r,a=t.length,i=m(a),o=e.map(function(e){return e[0]}).join(","),e=e.map(function(e,n){return e[0]+t[n]}).join(","),s=v("rc",a),u=v("source",a),l=s[a-1]+" < "+this.outputShape[a-1],d=1===a?"source":"vec2("+u.slice(-2).join()+")",n="reflect"===n?0:1,c="";c=1===a?"\n        "+i+" rc = outputLoc;\n        "+(r="\n        "+i+" source = rc;\n        if (source < start) {\n          source = start * 2 - source - "+n+";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + "+n+";\n        }\n        source -= start;\n      ")+"\n        result[0] = getChannel(getX("+u.join()+"), "+d+");\n        "+s[a-1]+" += 1;\n        if("+l+") {\n          "+r+"\n          result[1] = getChannel(getX("+u.join()+"), "+d+");\n        }\n      ":"\n        "+i+" rc = outputLoc;\n        "+(r="\n        "+i+" source = rc;\n        "+i+" lt = "+i+"(lessThan(source, start));\n        "+i+" gte = "+i+"(greaterThanEqual(source, end));\n        "+i+" orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - "+n+") +\n                gte * ((end - 1) * 2 - source + "+n+");\n        source -= start;\n      ")+"\n        result[0] = getChannel(getX("+u.join()+"), "+d+");\n        "+s[a-1]+" += 1;\n        if("+l+") {\n          "+r+"\n          result[1] = getChannel(getX("+u.join()+"), "+d+");\n        }\n        rc = outputLoc;\n        "+s[a-2]+" += 1;\n        if("+s[a-2]+" < "+this.outputShape[a-2]+") {\n          "+r+"\n          result[2] = getChannel(getX("+u.join()+"), "+d+");\n          "+s[a-1]+" += 1;\n          if("+l+") {\n            "+r+"\n            result[3] = getChannel(getX("+u.join()+"), "+d+");\n          }\n        }\n      ",this.userCode="\n      const "+i+" start = "+i+"("+o+");\n      const "+i+" end = "+i+"("+e+");\n\n      void main() {\n        "+i+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+c+"\n        setOutput(result);\n      }\n    "},io={kernelName:D.MirrorPad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.paddings,e=e.mode,r=new(D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?ao:ro)(n.shape,r,e);return t.runWebGLProgram(r,[n],n.dtype)}},oo=T({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),oo={kernelName:D.Mod,backendName:"webgl",kernelFunc:oo},so=(uo.prototype.getCustomSetupFunc=function(t){var r=this;return function(e,n){null==r.seedLoc&&(r.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(r.seedLoc,t)}},uo);function uo(e,n,t){this.variableNames=["probs"],this.outputShape=[e,t],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(n-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(n-1)+"));\n      }\n    "}var lo=T({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),co={kernelName:D.RealDiv,backendName:"webgl",kernelFunc:lo},po="return a - b;",ho=T({opSnippet:po,packedOpSnippet:po,supportsComplex:!0,cpuKernelImpl:Ln}),po={kernelName:D.Sub,backendName:"webgl",kernelFunc:ho};function fo(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.logits,e=e.dim,e=D.util.parseAxisParam([e],n.shape),r=ji({inputs:{x:n},backend:t,attrs:{reductionIndices:e,keepDims:!1}}),a=D.backend_util.expandShapeToKeepDim(r.shape,e),i=O({inputs:{x:r},backend:t,attrs:{shape:a}}),n=ho({inputs:{a:n,b:i},backend:t}),o=di({inputs:{x:n},backend:t}),e=sr({inputs:{x:o},backend:t,attrs:{axis:e,keepDims:!1}}),a=O({inputs:{x:e},backend:t,attrs:{shape:a}}),s=lo({inputs:{a:o,b:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(a),s}Ln={kernelName:D.Softmax,backendName:"webgl",kernelFunc:fo};var xo={kernelName:D.Multinomial,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.logits,r=e.numSamples,a=e.seed,e=e.normalized,i=(n=e?n:fo({inputs:{logits:n},backend:t,attrs:{dim:n.shape.length-1}})).shape[0],o=n.shape[1],o=(i=new so(i,o,r)).getCustomSetupFunc(a),r=t.runWebGLProgram(i,[n],"int32",o);return e||t.disposeIntermediateTensorInfo(n),r}},go="return -x;";var mo={kernelName:D.Neg,backendName:"webgl",kernelFunc:function(e){var n,t,r=e.inputs,e=e.backend,r=r.x;return e.shouldExecuteOnCPU([r])?(t=e.texData.get(r.dataId),n=(t=Xn(t.values,r.shape,r.dtype))[0],t=t[1],e.makeTensorInfo(t,r.dtype,n)):(t=new(D.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?Tt:C)(r.shape,go),e.runWebGLProgram(t,[r],r.dtype))}},vo=D.kernel_impls.nonMaxSuppressionV3Impl;var bo={kernelName:D.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){D.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,e=e.attrs,r=n.boxes,n=n.scores,a=e.maxOutputSize,i=e.iouThreshold,e=e.scoreThreshold,r=t.readSync(r.dataId),n=t.readSync(n.dataId),r=vo(r,n,a,i,e).selectedIndices;return t.makeTensorInfo([r.length],"int32",new Int32Array(r))}},Co=D.kernel_impls.nonMaxSuppressionV4Impl;var yo={kernelName:D.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){D.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,e=e.attrs,r=n.boxes,n=n.scores,a=e.maxOutputSize,i=e.iouThreshold,o=e.scoreThreshold,e=e.padToMaxOutputSize,r=t.readSync(r.dataId),n=t.readSync(n.dataId),n=(r=Co(r,n,a,i,o,e)).selectedIndices,a=r.validOutputs;return[t.makeTensorInfo([n.length],"int32",new Int32Array(n)),t.makeTensorInfo([],"int32",new Int32Array([a]))]}},ko=D.kernel_impls.nonMaxSuppressionV5Impl;var Io={kernelName:D.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){D.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,e=e.attrs,r=n.boxes,n=n.scores,a=e.maxOutputSize,i=e.iouThreshold,o=e.scoreThreshold,e=e.softNmsSigma,r=t.readSync(r.dataId),n=t.readSync(n.dataId),n=(r=ko(r,n,a,i,o,e)).selectedIndices,a=r.selectedScores;return[t.makeTensorInfo([n.length],"int32",new Int32Array(n)),t.makeTensorInfo([a.length],"float32",new Float32Array(a))]}},wo=function(e,n,t,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+t+"),\n                      float(index == coords.y)));\n      }\n    "},Ro={kernelName:D.OneHot,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.indices,r=e.depth,a=e.onValue,e=e.offValue,i=D.util.sizeFromShape(n.shape),a=new wo(i,r,a,e),e=O({inputs:{x:n},backend:t,attrs:{shape:[i]}}),i=t.runWebGLProgram(a,[e],n.dtype),a=(t.disposeIntermediateTensorInfo(e),n.shape.concat([r])),e=O({inputs:{x:i},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(i),e}};function To(e){var n,t,r,a,i,o=e.inputs,e=e.backend,o=o.x;return"complex64"===o.dtype?(i=w({inputs:{real:t=To({inputs:{x:n=ea({inputs:{input:o},backend:e})},backend:e}),imag:a=To({inputs:{x:r=xa({inputs:{input:o},backend:e})},backend:e})},backend:e}),e.disposeIntermediateTensorInfo(n),e.disposeIntermediateTensorInfo(t),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),i):mi({attrs:{shape:o.shape,dtype:o.dtype,value:"string"===o.dtype?"":0},backend:e})}var No={kernelName:D.ZerosLike,backendName:"webgl",kernelFunc:To};var Eo={kernelName:D.OnesLike,backendName:"webgl",kernelFunc:function e(n){var t,r,a,i,o,s=n.inputs,n=n.backend,s=s.x;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");return"complex64"===s.dtype?(o=w({inputs:{real:r=e({inputs:{x:t=ea({inputs:{input:s},backend:n})},backend:n}),imag:i=To({inputs:{x:a=xa({inputs:{input:s},backend:n})},backend:n})},backend:n}),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o):mi({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}};var So={kernelName:D.Pack,backendName:"webgl",kernelFunc:function(e){var n,t,r,a=e.inputs,i=e.backend,o=e.attrs.axis;return 1===a.length?ci({inputs:{input:a[0]},backend:i,attrs:{dim:o}}):(n=a[0].shape,t=a[0].dtype,a.forEach(function(e){D.util.assertShapesMatch(n,e.shape,"All tensors passed to stack must have matching shapes"),D.util.assert(t===e.dtype,function(){return"All tensors passed to stack must have matching dtypes"})}),r=[],e=va({inputs:a.map(function(e){e=ci({inputs:{input:e},backend:i,attrs:{dim:o}});return r.push(e),e}),backend:i,attrs:{axis:o}}),r.forEach(function(e){return i.disposeIntermediateTensorInfo(e)}),e)}},Ao=(Fo.prototype.getCustomSetupFunc=function(t){var r=this;return function(e,n){null==r.valueLoc&&(r.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(r.valueLoc,t)}},Fo);function Fo(t,e,n){this.variableNames=["x"],this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r=t.length,a=m(r),i=e.map(function(e){return e[0]}).join(","),e=e.map(function(e,n){return e[0]+t[n]}).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1===r?"\n        int start = "+i+";\n        int end = "+e+";\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ":"\n      "+a+" start = "+a+"("+i+");\n      "+a+" end = "+a+"("+e+");\n      uniform float value;\n\n      void main() {\n        "+a+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          "+a+" coords = outC - start;\n          setOutput(getX("+o+"));\n        }\n      }\n    "}Oo.prototype.getCustomSetupFunc=function(t){var r=this;return function(e,n){null==r.valueLoc&&(r.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(r.valueLoc,t)}};var _o=Oo;function Oo(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});for(var r=t.length,a=m(r),i=e.map(function(e){return e[0]}).join(","),e=e.map(function(e,n){return e[0]+t[n]}).join(","),o=v("rc",r),s=v("source",r),u=o[r-1]+" < "+this.outputShape[r-1],l=1===r?"source":"vec2("+s.slice(-2).join()+")",d=[a+" rc = outputLoc;",o[r-1]+" += 1;\n       if("+u+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+o[r-2]+" += 1;\n       if("+o[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+o[r-1]+" += 1;\n         if("+u+") {"],c=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="",h=0,f=1===r?2:4;h<f;h++)p+="\n        "+d[h]+"\n        if ("+c+") {\n          result["+h+"] = float(value);\n        } else {\n          "+a+" source = rc - start;\n          result["+h+"] = getChannel(getX("+s.join()+"), "+l+");\n        }\n      ";this.userCode="\n      const "+a+" start = "+a+"("+i+");\n      const "+a+" end = "+a+"("+e+");\n      uniform float value;\n\n      void main() {\n        "+a+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+(p+=1===r?"} ":"}}")+"\n        setOutput(result);\n      }\n    "}function Do(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.paddings,e=e.constantValue,e=(r=new(D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?_o:Ao)(n.shape,r,e)).getCustomSetupFunc(e);return t.runWebGLProgram(r,[n],n.dtype,e)}var Lo={kernelName:D.PadV2,backendName:"webgl",kernelFunc:Do},Po=T({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Po={kernelName:D.Pow,backendName:"webgl",kernelFunc:Po};function Bo(e){var n=e.backend,t=(e=e.attrs).start,r=e.stop,a=e.step,e=e.dtype,t=jn(t,r,a,e);return n.makeTensorInfo([t.length],e,t)}var Vo={kernelName:D.Prod,backendName:"webgl",kernelFunc:function(e){var n,t,r=e.inputs,a=e.backend,e=e.attrs,r=r.x,i=e.axis,e=e.keepDims,o=r.shape.length,s=[],u=i=D.util.parseAxisParam(i,r.shape),l=D.backend_util.getAxesPermutation(u,o),d=r;return null!=l&&(d=M({inputs:{x:r},backend:a,attrs:{perm:l}}),u=D.backend_util.getInnerMostAxes(u.length,o),s.push(d)),D.backend_util.assertAxesAreInnerMostDims("prod",u,o),a.shouldExecuteOnCPU([d])?(l=a.texData.get(d.dataId).values,l=(o=Hn(d.shape,d.dtype,l,u)).outVals,t=o.outShape,o=o.outDtype,n=a.makeTensorInfo(t,o,l)):(t=(o=D.backend_util.computeOutAndReduceShapes(d.shape,u))[0],l=o[1],u=D.util.sizeFromShape(l),o=O({inputs:{x:d},backend:a,attrs:{shape:[-1,u]}}),n=O({inputs:{x:l=N(o,D.sumOutType(r.dtype),"prod",a)},backend:a,attrs:{shape:t}}),s.push(o),s.push(l)),e&&(s.push(n),d=D.backend_util.expandShapeToKeepDim(n.shape,i),n=O({inputs:{x:n},backend:a,attrs:{shape:d}})),s.forEach(function(e){return a.disposeIntermediateTensorInfo(e)}),n}},Wo={kernelName:D.Range,backendName:"webgl",kernelFunc:Bo},Mo=R({opSnippet:"return 1.0 / x;"}),Mo={kernelName:D.Reciprocal,backendName:"webgl",kernelFunc:Mo},Go=R({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Go={kernelName:D.Relu,backendName:"webgl",kernelFunc:Go},Uo=R({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Uo={kernelName:D.Relu6,backendName:"webgl",kernelFunc:Uo},zo=function(e,n,t,r,a){this.variableNames=["A"],this.outputShape=[];var i=e[0],o=e[1],s=e[2],e=e[3],i=(this.outputShape=[i,n,t,e],[r&&1<n?o-1:o,r&&1<t?s-1:s]),e=[r&&1<n?n-1:n,r&&1<t?t-1:t],n=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+i[0]/e[0]+",\n          "+i[1]/e[1]+");\n      const vec2 inputShapeRC = vec2("+o+".0, "+s+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = "+n+";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "},Xo=function(e,n,t,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var i=e[0],o=e[1],s=e[2],e=e[3],i=(this.outputShape=[i,n,t,e],[r&&1<n?o-1:o,r&&1<t?s-1:s]),n=[r&&1<n?n-1:n,r&&1<t?t-1:t],r=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC";this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+i[0]/n[0]+",\n          "+i[1]/n[1]+",\n          "+i[1]/n[1]+");\n      const vec3 inputShapeRC = vec3("+o+".0, "+s+".0,\n                                     "+s+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = "+r+";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(e-1)+";\n        bool hasNextRow = coords.z < "+(t-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "};var Ho={kernelName:D.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.images,r=e.alignCorners,a=e.halfPixelCenters,i=(e=e.size)[0],e=e[1],i=new(D.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?Xo:zo)(n.shape,i,e,r,a);return t.runWebGLProgram(i,[n],"float32")}},jo=function(e,n,t){this.variableNames=["dy"],this.outputShape=[];var r=(this.outputShape=n)[1],n=n[2],a=e[1],e=e[2],i=[t&&1<a?r-1:r,t&&1<e?n-1:n],t=[t&&1<a?a-1:a,t&&1<e?e-1:e],o=i[0]/t[0],i=i[1]/t[1],t=1/o,s=1/i,u=2*Math.ceil(t)+2,l=2*Math.ceil(s)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+o+");\n        const float widthScale = float("+i+");\n\n        const float invHeightScale = float("+t+");\n        const float invWidthScale = float("+s+");\n\n        const int winHeight = int("+u+");\n        const int winWidth = int("+l+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+a+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+e+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(r-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(n-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "};var Ko={kernelName:D.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.images,n=n.dy,e=e.alignCorners,r=new jo(n.shape,r.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}},qo=function(e,n,t,r,a){this.variableNames=["A"],this.outputShape=[];var i=e[0],o=e[1],s=e[2],e=e[3],i=(this.outputShape=[i,n,t,e],[r&&1<n?o-1:o,r&&1<t?s-1:s]),e=[r&&1<n?n-1:n,r&&1<t?t-1:t],n=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+i[0]/e[0]+",\n          "+i[1]/e[1]+");\n      const vec2 inputShapeRC = vec2("+o+".0, "+s+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = "+n+";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+(r?"0.5":"0.0")+")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "},Yo=function(e,n,t,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var i=e[0],o=e[1],s=e[2],e=e[3],i=(this.outputShape=[i,n,t,e],[r&&1<n?o-1:o,r&&1<t?s-1:s]),n=[r&&1<n?n-1:n,r&&1<t?t-1:t],a=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC";this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+i[0]/n[0]+",\n          "+i[1]/n[1]+",\n          "+i[1]/n[1]+");\n      const vec3 inputShapeRC = vec3("+o+".0, "+s+".0,\n                                     "+s+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = "+a+";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+(r?"0.5":"0.0")+")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(e-1)+";\n        bool hasNextRow = coords.z < "+(t-1)+";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    "};var Qo={kernelName:D.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.images,r=e.alignCorners,a=e.halfPixelCenters,i=(e=e.size)[0],e=e[1],i=new(D.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?Yo:qo)(n.shape,i,e,r,a);return t.runWebGLProgram(i,[n],n.dtype)}},Zo=function(e,n,t){this.variableNames=["dy"],this.outputShape=[];var r=(this.outputShape=n)[1],n=n[2],a=e[1],e=e[2],i=[t&&1<a?r-1:r,t&&1<e?n-1:n],o=[t&&1<a?a-1:a,t&&1<e?e-1:e],s=i[0]/o[0],u=i[1]/o[1],l=1/s,d=1/u,c=2*Math.ceil(l)+2,p=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+s+");\n        const float widthScale = float("+u+");\n\n        const float invHeightScale = float("+l+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+c+");\n        const int winWidth = int("+p+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+a+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+e+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+i[0]+") *\n                (float(dyR) / float("+o[0]+"));\n\n            float sourceFracCol =\n                float("+i[1]+") *\n                  (float(dyC) / float("+o[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+r+") - 1),\n                "+t+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+n+") - 1),\n                "+t+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "};var $o={kernelName:D.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.images,n=n.dy,e=e.alignCorners,r=new Zo(n.shape,r.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}},Jo=function(t,r){this.variableNames=["x"];var e,n=t.length;if(4<n)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t,1===n?this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      ":(e=t.map(function(e,n){return n=n,-1!==r.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}).join(","),n=m(n),this.userCode="\n      void main() {\n        "+n+" coords = getOutputCoords();\n        setOutput(getX("+e+"));\n      }\n    ")},es=function(a,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var e=a.length;if(4<e)throw new Error("WebGL backend: Reverse of rank-"+e+" tensor is not yet supported");this.outputShape=a;var n=v("rc",e),t=n[e-1]+" + 1 < "+this.outputShape[e-1],r=n[e-2]+" + 1 < "+this.outputShape[e-2],o=m(e);function s(r){var e=a.map(function(e,n){return n=n,t=r,-1!==i.indexOf(n)&&1!==a[n]?a[n]+" - "+t[n]+" - 1":""+t[n];var t});return"getChannel(getX("+e.join(",")+"), vec2("+e.slice(-2).join(",")+"))"}this.userCode=1===e?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+a[0]+" - rc - 1),\n            "+a[0]+" - rc - 1);\n          if("+t+"){\n              result.g = getChannel(getX("+a[0]+" - (rc  + 1) - 1),\n                "+a[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+o+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+s(n.slice())+";\n          if("+t+"){\n            result.g = "+((o=n.slice())[e-1]="("+o[e-1]+" + 1)",s(o))+";\n          }\n          if("+r+") {\n            result.b = "+((o=n.slice())[e-2]="("+o[e-2]+" + 1)",s(o))+";\n            if("+t+") {\n              result.a = "+((r=n.slice())[e-1]="("+r[e-1]+" + 1)",r[e-2]="("+r[e-2]+" + 1)",s(r))+";\n            }\n          }\n          setOutput(result);\n        }\n    "};var ns={kernelName:D.Reverse,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,e=e.dims,r=n.shape.length,e=D.util.parseAxisParam(e,n.shape);return 0===r?I({inputs:{x:n},backend:t}):(r=new(D.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?es:Jo)(n.shape,e),t.runWebGLProgram(r,[n],n.dtype))}},ts=(rs.prototype.getCustomSetupFunc=function(t,r,a,i){var o=this;return function(e,n){null==o.paramsLoc&&(o.paramsLoc=e.getUniformLocationNoThrow(n,"params")),e.gl.uniform4f(o.paramsLoc,t,r,a,i)}},rs);function rs(e,n){this.variableNames=["Image"],this.outputShape=[];var t=e[1],r=e[2],e=(this.outputShape=e,""),e="number"==typeof n?"float outputValue = "+n.toFixed(2)+";":"\n        vec3 fill = vec3("+n.join(",")+");\n        float outputValue = fill[coords[3]];";this.userCode="\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          "+e+"\n          if(coordX >= 0 && coordX < "+r+" && coordY >= 0 && coordY < "+t+") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    "}var as={kernelName:D.RotateWithOffset,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,e=e.backend,n=n.image,r=t.radians,a=t.fillValue,t=t.center,a=new ts(n.shape,a),t=D.backend_util.getImageCenter(t,n.shape[1],n.shape[2]),i=t[0],t=t[1],i=a.getCustomSetupFunc(i,t,Math.sin(r),Math.cos(r));return e.runWebGLProgram(a,[n],n.dtype,i)}},is=R({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),is={kernelName:D.Round,backendName:"webgl",kernelFunc:is},On=R({opSnippet:"return inversesqrt(x);",cpuKernelImpl:On}),On={kernelName:D.Rsqrt,backendName:"webgl",kernelFunc:On},os=function(e,n,t,r,a,i,o){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;var s=m(a.length),i=m(i.length),u="";1===t?u="i":2===t&&(u="i, j"),t="",1===r?t="i":2===r&&(t="i, coords[1]"),this.userCode="\n        "+s+" strides = "+s+"("+a+");\n\n        void main() {\n          "+i+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+e+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+n+"; j++) {\n              int index = round("+("getIndices("+u+")")+");\n              flattenedIndex += index * "+(1<n?"strides[j]":"strides")+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+("getUpdates("+t+")")+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "};var ss={kernelName:D.ScatterNd,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.indices,n=n.updates,e=e.shape,a=D.backend_util.calculateShapes(n,r,e),i=a.sliceRank,o=a.numUpdates,s=a.sliceSize,u=a.strides,l=[(a=a.outputSize)/s,s];return 0===a?t.makeTensorInfo(e,r.dtype):(a=O({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),r=O({inputs:{x:n},backend:t,attrs:{shape:[o,s]}}),n=t.makeTensorInfo([],"float32",new Float32Array([0])),s=new os(o,i,a.shape.length,r.shape.length,u,l),i=O({inputs:{x:o=t.runWebGLProgram(s,[r,a,n],r.dtype)},backend:t,attrs:{shape:e}}),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(n),i)}},us=function(e,n,t){var r,a;if(this.variableNames=["c","a","b"],this.outputShape=n,4<t)throw Error("Where for rank "+t+" is not yet supported");if(1===t)r=a="resRC";else{for(var i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[],u=0;u<n.length;u++)s.push(""+i[u]),u<e&&o.push(""+i[u]);r=o.join(),a=s.join()}t=m(t),this.userCode="\n      void main() {\n        "+t+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+a+"));\n        } else {\n          setOutput(getB("+a+"));\n        }\n      }\n    "};var ls={kernelName:D.Select,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.condition,r=n.t,n=n.e,a=new us(t.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(a,[t,r,n],D.upcastType(r.dtype,n.dtype))}},ds=R({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+D.backend_util.SELU_SCALEALPHA+";\n  float scale = "+D.backend_util.SELU_SCALE+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n"}),ds={kernelName:D.Selu,backendName:"webgl",kernelFunc:ds},cs=R({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),cs={kernelName:D.Sigmoid,backendName:"webgl",kernelFunc:cs},ps=R({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ps={kernelName:D.Sign,backendName:"webgl",kernelFunc:ps},hs=R({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),hs={kernelName:D.Sin,backendName:"webgl",kernelFunc:hs},fs=R({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),fs={kernelName:D.Sinh,backendName:"webgl",kernelFunc:fs},xs=R({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),xs={kernelName:D.Softplus,backendName:"webgl",kernelFunc:xs},gs={kernelName:D.SpaceToBatchND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=e.blockShape,e=e.paddings,a=(D.util.assert(r.shape.length<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}),n.reduce(function(e,n){return e*n})),i=[[0,0]];i.push.apply(i,e);for(var o=1+n.length;o<r.shape.length;++o)i.push([0,0]);var e=[],s=Do({inputs:{x:r},backend:t,attrs:{paddings:i,constantValue:0}}),u=D.backend_util.getReshaped(s.shape,n,a,!1),l=D.backend_util.getPermuted(u.length,n.length,!1),n=D.backend_util.getReshapedPermuted(s.shape,n,a,!1),a=O({inputs:{x:s},backend:t,attrs:{shape:u}}),u=M({inputs:{x:a},backend:t,attrs:{perm:l}}),l=O({inputs:{x:u},backend:t,attrs:{shape:n}});return e.push(s),e.push(a),e.push(u),e.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),l}};var ms={kernelName:D.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.indices,r=n.values,a=n.denseShape,n=n.defaultValue;if(1!==a.shape.length)throw new Error("Dense shape must be a vector, saw:\n         "+a.shape);if(2!==t.shape.length)throw new Error("Indices must be a matrix, saw:\n         "+t.shape);if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         "+r.shape);if(0!==n.shape.length)throw new Error("Default value must be a scalar, saw:\n        "+n.shape);var i=e.readSync(t.dataId),o=e.readSync(r.dataId),a=e.readSync(a.dataId),n=e.readSync(n.dataId)[0],o=(i=Yn(i,t.shape,t.dtype,o,r.dtype,a,n))[0],a=i[1],n=i[2],s=i[3],i=i[4];return[e.makeTensorInfo(a,t.dtype,o),e.makeTensorInfo([a[0]],r.dtype,n),e.makeTensorInfo([s.length],"bool",new Uint8Array(s.map(function(e){return Number(e)}))),e.makeTensorInfo([i.length],t.dtype,new Int32Array(i))]}};var vs={kernelName:D.SparseReshape,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.inputIndices,r=n.inputShape,n=n.newShape;if(2!==t.shape.length)throw new Error("Input indices should be a matrix but received shape "+t.shape);if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape "+r.shape);if(1!==n.shape.length)throw new Error("Target shape should be a vector but received shape "+n.shape);var r=Array.from(e.readSync(r.dataId)),a=e.readSync(t.dataId),i=Array.from(e.readSync(n.dataId)),r=(a=Qn(a,t.shape,t.dtype,r,i))[0],i=a[1],a=a[2];return[e.makeTensorInfo(i,t.dtype,r),e.makeTensorInfo([a.length],n.dtype,new Int32Array(a))]}};var bs={kernelName:D.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.data,r=n.indices,n=n.segmentIds;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              "+r.shape);if(1!==n.shape.length)throw new Error("Segment ids should be a vector but received shape\n              "+n.shape);var a=e.readSync(t.dataId),r=e.readSync(r.dataId),n=e.readSync(n.dataId),r=(a=Zn(a,t.shape,t.dtype,r,n,!0))[0],n=a[1];return e.makeTensorInfo(n,t.dtype,r)}};var Cs={kernelName:D.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,e=e.backend,t=n.data,r=n.indices,n=n.segmentIds;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             "+r.shape);if(1!==n.shape.length)throw new Error("Segment ids should be a vector but received shape\n             "+n.shape);var a=e.readSync(t.dataId),r=e.readSync(r.dataId),n=e.readSync(n.dataId),r=(a=Zn(a,t.shape,t.dtype,r,n))[0],n=a[1];return e.makeTensorInfo(n,t.dtype,r)}};var ys={kernelName:D.SparseToDense,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.sparseIndices,a=n.sparseValues,n=n.defaultValue,e=e.outputShape,i=(u=D.backend_util.calculateShapes(a,r,e)).sliceRank,o=u.numUpdates,s=u.strides,u=u.outputSize,o=new os(o,i,r.shape.length,a.shape.length,s,[u,1],!1),s=O({inputs:{x:i=t.runWebGLProgram(o,[a,r,n],a.dtype)},backend:t,attrs:{shape:e}});return t.disposeIntermediateTensorInfo(i),s}};var ks={kernelName:D.SplitV,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.x,n=e.numOrSizeSplits,e=e.axis,a=D.util.parseAxisParam(e,r.shape)[0],e=D.backend_util.prepareSplitSize(r,n,a),n=r.shape.length,i=new Array(n).fill(0),o=r.shape.slice();return e.map(function(e){var n=o.slice(),n=(n[a]=e,Yr({inputs:{x:r},backend:t,attrs:{begin:i,size:n}}));return i[a]+=e,n})}},Is=R({opSnippet:"return sqrt(x);"}),Is={kernelName:D.Sqrt,backendName:"webgl",kernelFunc:Is},ws=R({opSnippet:"return x * x;"}),ws={kernelName:D.Square,backendName:"webgl",kernelFunc:ws},Rs="return (a - b) * (a - b);",Rs=T({opSnippet:Rs,packedOpSnippet:Rs}),Rs={kernelName:D.SquaredDifference,backendName:"webgl",kernelFunc:Rs};var Ts={kernelName:D.Step,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,e=e.backend,n=n.x,t=ht+"\n    return x > 0.0 ? 1.0 : float("+t.alpha+");\n  ",t=new C(n.shape,t);return e.runWebGLProgram(t,[n],n.dtype)}},Ns=function(e,n,t){this.variableNames=["x"];var r,a=(this.outputShape=t).length,i=m(t.length),o=m(t.length),s="";s=1===a?"coords * strides + begin":(r=0,t.map(function(e,n){return r++,1===t.length?"coords * strides["+n+"] + begin["+n+"]":"coords["+(r-1)+"] * strides["+n+"] + begin["+n+"]"}).join(",")),this.userCode="\n      "+i+" begin = "+i+"("+e+");\n      "+i+" strides = "+i+"("+n+");\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+s+"));\n      }\n    "};var Es={kernelName:D.StridedSlice,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,r=e.backend,e=e.attrs,t=t.x,a=e.begin,i=e.end,o=e.strides,s=e.beginMask,u=e.endMask,l=e.ellipsisMask,d=e.newAxisMask,e=e.shrinkAxisMask,i=(a=D.slice_util.sliceInfo(t.shape,a,i,o,s,u,l,d,e)).nonStrided,o=a.$begin,s=a.$strides,u=a.size,l=a.newShape,d=a.outShape,e=O({inputs:{x:t},backend:r,attrs:{shape:l}}),t=(i?(n=O({inputs:{x:a=Yr({inputs:{x:e},backend:r,attrs:{begin:o,size:u}})},backend:r,attrs:{shape:d}}),r.disposeIntermediateTensorInfo(a)):n=d.some(function(e){return 0===e})?r.makeTensorInfo(d,t.dtype,[]):r.shouldExecuteOnCPU([e])?(l=r.texData.get(e.dataId).values,i=D.buffer(e.shape,e.dtype,l),u=$n(d,i,s,o),r.makeTensorInfo(d,e.dtype,u.values)):(a=new Ns(o,s,d),r.runWebGLProgram(a,[e],e.dtype)),O({inputs:{x:n},backend:r,attrs:{shape:d}}));return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),t}};var Ss={kernelName:D.StringNGrams,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=(e=e.attrs).separator,a=e.nGramWidths,i=e.leftPad,o=e.rightPad,s=e.padWidth,e=e.preserveShortSequences,u=n.data,n=n.dataSplits,u=t.readSync(u.dataId),l=t.readSync(n.dataId),l=(u=Jn(u,l,r,a,i,o,s,e))[0],r=u[1];return[t.makeTensorInfo([l.length],"string",l),t.makeTensorInfo(n.shape,"int32",r)]}};var As={kernelName:D.StringSplit,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs.skipEmpty,r=n.input,n=n.delimiter;if("string"!==r.dtype)throw new Error("Input must be of datatype string");if(1!==r.shape.length)throw new Error("Input must be a vector, got shape: "+r.shape);if(0!==n.shape.length)throw new Error("Delimiter must be a scalar, got shape: "+n.shape);var r=t.readSync(r.dataId),n=t.readSync(n.dataId)[0],n=(r=et(r,n,e))[0],e=r[1],r=r[2],a=e.length;return[t.makeTensorInfo([a,2],"int32",n),t.makeTensorInfo([a],"string",e),t.makeTensorInfo([2],"int32",new Int32Array(r))]}};var Fs={kernelName:D.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs.numBuckets;if("string"!==(n=n.input).dtype)throw new Error("Input must be of datatype string");if(e<=0)throw new Error("Number of buckets must be at least 1");var r=t.readSync(n.dataId),r=nt(r,e);return t.makeTensorInfo(n.shape,"int32",r)}},_s=R({opSnippet:"return tan(x);"}),_s={kernelName:D.Tan,backendName:"webgl",kernelFunc:_s},Os=R({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Os={kernelName:D.Tanh,backendName:"webgl",kernelFunc:Os},Ds=function(e,n){this.variableNames=["A"];for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[r]*n[r];this.outputShape=t,this.rank=t.length;var a=m(this.rank),i=function(e){var n=e.length;if(5<n)throw Error("Tile for rank "+n+" is not yet supported");if(1===n)return"imod(resRC, "+e[0]+")";for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],a=0;a<e.length;a++)r.push("imod("+t[a]+", "+e[a]+")");return r.join()}(e);this.userCode="\n      void main() {\n        "+a+" resRC = getOutputCoords();\n        setOutput(getA("+i+"));\n      }\n    "};function Ls(e){var n,t=e.inputs,r=e.backend,e=e.attrs,t=t.x,e=e.reps;return"string"===t.dtype||5<t.shape.length?(n=r.readSync(t.dataId),n="string"===t.dtype?n.map(function(e){return D.util.decodeString(e)}):n,n=D.buffer(t.shape,t.dtype,n),n=tt(n,e),r.makeTensorInfo(n.shape,n.dtype,n.values)):(n=new Ds(t.shape,e),r.runWebGLProgram(n,[t],t.dtype))}var Ps={kernelName:D.Tile,backendName:"webgl",kernelFunc:Ls};var Bs={kernelName:D.TopK,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,n=n.x,r=e.k,e=(e.sorted,t.readSync(n.dataId)),n=(e=rt(e,n.shape,n.dtype,r))[0],r=e[1];return[t.makeTensorInfo(n.shape,n.dtype,n.values),t.makeTensorInfo(r.shape,r.dtype,r.values)]}},Vs=function(e,n,t,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;var o,i="nearest"===t?1:2;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if("+o+" == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if ("+o+" == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if ("+o+" == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < "+e+" && 0 <= coordX && coordX < "+n+") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float("+a+");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float("+a+");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float("+n+"));\n                float mapY = mapCoord(inY, float("+e+"));\n\n                if ("+i+" == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        "};var Ws={kernelName:D.Transform,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,e=e.attrs,r=n.image,n=n.transforms,a=e.interpolation,i=e.fillMode,o=e.fillValue,e=e.outputShape,s=(d=r.shape)[0],u=d[1],l=d[2],d=d[3],c=(e=null!=e?e:[u,l])[0],e=e[1],u=new Vs(u,l,a,i,o,[s,c,e,d]);return t.runWebGLProgram(u,[r,n],"float32")}};var Ms={kernelName:D.Unique,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,e=e.backend,t=t.axis,r=(u(n=n.x,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded"),e.readSync(n.dataId)),t=(r=it(r,t,n.shape,n.dtype)).outputValues,a=r.outputShape,r=r.indices;return[e.makeTensorInfo(a,n.dtype,t),e.makeTensorInfo([r.length],"int32",r)]}};var Gs={kernelName:D.Unpack,backendName:"webgl",kernelFunc:function(e){for(var n=e.inputs,t=e.backend,e=e.attrs,n=n.value,r=e.axis,a=(r<0&&(r+=n.shape.length),n),i=a.shape.length,e=n.shape[r],o=new Array(i-1),s=0,u=0;u<i;u++)u!==r&&(o[s++]=a.shape[u]);for(var l=[],d=new Array(i).fill(0),c=a.shape.slice(),p=(c[r]=1,new Array(e)),u=0;u<p.length;u++){d[r]=u;var h=Yr({inputs:{x:a},backend:t,attrs:{begin:d,size:c}}),f=O({inputs:{x:h},backend:t,attrs:{shape:o}});p[u]=f,l.push(h)}return l.forEach(function(e){return t.disposeIntermediateTensorInfo(e)}),p}},Us=function(e,n){this.variableNames=["x","segmentIds"];var t=e.windowSize,r=e.batchSize,a=e.inSize,i=(e=e.numSegments)*Math.ceil(a/t),r=(this.outputShape=[r,i],4*Math.floor(t/4)),i=t%4,o="\n        sumValue += dot(values, segFilter);\n    ",s="",u="";this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+(s=0<a%t?"\n        if (inIdx < 0 || inIdx >= "+a+") {\n          return initializationValue;\n        }\n      ":s)+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+(u=0<a%t?"\n        if (inIdx < 0 || inIdx >= "+a+") {\n          return -1.0;\n        }\n      ":u)+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+e+")) * float("+t+"));\n        int currentSeg = int(mod(float(outIdx), float("+e+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+r+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+o+"\n        }\n\n        int inIdx = inOffset + "+r+";\n        if ("+(1==i)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+o+"\n        } else if ("+(2==i)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+o+"\n        } else if ("+(3==i)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+o+"\n        }\n        setOutput(sumValue);\n      }\n    "};for(var zs=0,Xs=[zi,Hi,pr,fr,xr,gr,mn,mr,Cr,yr,Rr,Tr,Nr,Er,Ar,Sr,Fr,Lr,Dr,Vr,Wr,Mr,zr,Zr,$r,ra,bn,aa,ca,Gt,ba,Aa,Fa,Ra,Oa,Da,_a,La,Pa,Va,za,Xa,Ka,Ja,ei,Qa,ti,ai,ii,oi,si,Cn,ui,li,yn,kn,pi,bi,yi,In,ki,Ri,Ti,Ni,Si,Fi,wn,Rn,Mt,_i,ga,Oi,Di,Li,Xt,Tn,Nn,Pi,Bi,En,Vi,Wi,Mi,Ki,Yi,qi,$i,Ji,eo,Sn,no,to,An,io,oo,xo,er,mo,bo,yo,Io,_n,Ro,Eo,So,Lo,Po,Kt,Vo,Wo,na,co,Mo,Uo,Go,nr,Ho,Ko,Qo,$o,ns,as,is,On,ss,ls,ds,cs,ps,hs,fs,Qr,Ln,xs,gs,ms,vs,bs,Cs,ys,ks,Is,ws,Rs,Ts,Es,Ss,As,Fs,po,ur,_s,Os,Ps,Bs,Ws,lr,Ms,Gs,{kernelName:D.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){function u(e,n,t,r,a){var i=e.shape[0],o=e.shape[1],s=D.backend_util.segment_util.segOpComputeOptimalWindowSize(o,a),i=new Us({windowSize:s,inSize:o,batchSize:i,numSegments:a},n),i=l.compileAndRun(i,[e,t],r);return d.push(i),i.shape[1]===a?i:(t=Ls({inputs:{x:e=Bo({backend:l,attrs:{start:0,stop:a,step:1,dtype:"float32"}})},backend:l,attrs:{reps:[o/s]}}),d.push(e),d.push(t),u(i,n,t,r,a))}var n=e.inputs,l=e.backend,e=e.attrs,t=n.x,n=n.segmentIds,e=e.numSegments,r=t.shape.length,d=[],a=0,i=D.backend_util.getAxesPermutation([a],r),o=t,r=(null!=i&&(o=M({inputs:{x:t},backend:l,attrs:{perm:i}}),d.push(o),a=D.backend_util.getInnerMostAxes(1,r)[0]),D.backend_util.segment_util.computeOutShape(o.shape,a,e)),a=D.util.sizeFromShape([o.shape[a]]),o=O({inputs:{x:o},backend:l,attrs:{shape:[-1,a]}}),a=(d.push(o),D.sumOutType(t.dtype)),o=t=O({inputs:{x:u(o,"unsortedSegmentSum",n,a,e)},backend:l,attrs:{shape:r}});return null!=i&&(d.push(t),n=D.backend_util.getUndoAxesPermutation(i),o=M({inputs:{x:o},backend:l,attrs:{perm:n}})),d.forEach(function(e){return l.disposeIntermediateTensorInfo(e)}),o}},No];zs<Xs.length;zs++)D.registerKernel(Xs[zs]);e.GPGPUContext=sn,e.MathBackendWebGL=Dt,e.forceHalfFloat=Pt,e.gpgpu_util=on,e.setWebGLContext=G,e.version_webgl="3.7.0",e.webgl=Bt,e.webgl_util=n,Object.defineProperty(e,"__esModule",{value:!0})});